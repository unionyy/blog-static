var store = [{
        "title": "[subtree] GitHub Repository 합치기",
        "excerpt":"  git subtree add를 이용하면,   하나의 repository 안에 다른 repository를 그대로 복사해올 수 있습니다.   이때, 기존의 commit log를 함께 복사해올 수 있습니다!    문제점  코딩 실습들을 개별 Repository에서 진행하면서 문제가 생겼습니다.     실습용 repository들이 쌓여서 지저분해보인다.   fork해와서 진행한 실습들은 Contribution Graph에 표시되지 않는다.   git subtree add   git subtree add --prefix=(해당 Repository 하위의 디렉터리 구조) (옮겨올 Repository 주소) (옮겨올 Repository의 branch)    저의 경우,  git subtree add --prefix=nodejs-practice https://github.com/unionyy/nodejs-practice main   기존 repository의 commit log를 없애려면 --squash 옵션을 마지막에 추가하면 됩니다.   결과  하나의 repository의 하위 디렉토리 안에 각각의 repository가 복사되었습니다.    기존의 commit log들도 성공적으로 옮겨졌습니다.    단점  각각의 파일의 commit history를 확인하기 어려워집니다.    개별 파일 또는 디렉토리의 commit history가 제대로 보여지지 않습니다.   repository를 복사할 때 만들어진 commit 하나만 보여집니다.   찾을 내용이 생기면 repository 전체 히스토리를 참고해야 할 듯 합니다.   Reference     Git Repository 합치기 (commit log 유지) - subtree 이용   Git subtree: the alternative to Git submodule  ","categories": ["GitHub"],
        "tags": ["GitHub","Subtree","Repository","Commit Log"],
        "url": "/github/subtree/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "Visual Studio Code에서 Markdown(.md) 미리보기",
        "excerpt":"  GitHub에 REAMDME 파일을 작성할 때   Jekyll을 이용하여 GitHub Page를 만들 때   Markdown(.md)을 사용합니다.   이를 작성과 동시에 미리보고자 합니다.    단축키 ctrl+k v  Markdown 파일이 열린 상태에서   ctrl+k를 누르고 1초 내에 v를 누르면   화면이 분할되고 오른쪽에 미리보기 창이 열립니다.    GitHub 스타일 마크다운 적용  이곳에서 markdownpad-github.css 파일을 받아 프로젝트 폴더 안에 넣어줍니다.   그리고 Settings &gt; Extensions &gt; Markdown에서   다음과 같이 markdownpad-github.css를 추가해줍니다.    GitHub Style Mardown 미리보기 적용 완료.    Reference     Visual Studio Code 에서 깃헙 스타일 마크다운 사용하기   Could not load ‘markdown.styles’: *.css   GitHub/aliencube/markdownpad-github  ","categories": ["Visual Studio Code"],
        "tags": ["Visual Studio Code","Markdown","GitHub"],
        "url": "/vscode/markdown/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "Node.js로 네이버 크롤링하기(맛보기)",
        "excerpt":"  Node.js를 이용하면 웹 크롤링을 간편하게 해볼 수 있습니다.   저는 crawler모듈을 사용하여 네이버 홈페이지를 크롤링해보겠습니다.   GitHub에서 코드 미리보기   목표   네이버 메인페이지에서 언론사 리스트를 가져와 출력해보고자 합니다.       Crawler 모듈 설치  모듈의 사용법은 모듈이 업데이트됨에 따라 달라질 수 있으므로,   공식문서를 참고하시는 것을 추천드립니다.   아래의 명렁어를 통해 crawler 모듈을 설치할 수 있습니다.  npm install crawler --save  공식 문서에 나와있는 기본 사용법 중에서   아래의 코드를 그대로 복사해서 이용해 보겠습니다. (주석 참조)  var Crawler = require(\"crawler\");   var c = new Crawler({     maxConnections : 10,     // This will be called for each crawled page     callback : function (error, res, done) {         if(error){             console.log(error);         }else{             var $ = res.$;             // $ is Cheerio by default             //a lean implementation of core jQuery designed specifically for the server             console.log($(\"title\").text());              /***************************************************             이부분에서 jQuery를 이용해 데이터를 파싱하고 출력할 것입니다.             ****************************************************/         }         done();     } });   // Queue just one URL, with default callback c.queue('http://www.naver.com'); // url은 네이버의 주소로 변경해줍니다.  이 코드는 title정보를 출력하는 코드이기 때문에   실행하면 NAVER가 출력됩니다.   코드를 수정하여 언론사 목록을 출력해봅시다!   크롤링 타겟 파악  웹페이지의 크롤링하고자 하는 부분에서   마우스 우클릭 &gt; 검사를 눌러줍니다.(크롬 브라우저 기준)   저는 네이버 메인페이지에서 언론사 리스트를 가져오고 싶으므로   밑의 이미지와 같은 위치에서 검사를 해주었습니다.      html코드 위에서 마우스를 움직이면서 타겟이 어떤 태그 안에 있는지 찾아줍니다.      언론사의 리스트는 \"thumb_area\"의 클래스 이름을 가진 div태그 안에 있었습니다.   각각의 언론사는 \"thumb_box\"의 클래스 이름을 가진 div태그안에 있었습니다.   jQuery로 데이터 파싱  crwaler 모듈의 베이스 코드를 보면,   jQuery를 사용할 수 있도록 변수 $가 정의되어 있습니다.   jQuery를 사용해 원하는 부분을 $bodyList에 저장해줍니다.   const $bodyList = $(\"div.thumb_area\").children(\"div.thumb_box\");   제가 찾는 언론사의 이름 정보는   a 태그 내부의 img태그의 alt 속성에 정의되어 있었습니다.      역시나 jQuery를 이용하여 원하는 정보를 추출해 줍니다.   let newsList = []; $bodyList.each(function(i, elem) {     newsList[i] = $(this).find('a.thumb img').attr('alt');   });   결과  콘솔에 결과를 출력해 줍니다.  console.log(newsList);     성공!   완성된 코드 GitHub  var Crawler = require(\"crawler\");   var c = new Crawler({     maxConnections : 10,     // This will be called for each crawled page     callback : function (error, res, done) {         if(error){             console.log(error);         }else{             var $ = res.$;             // $ is Cheerio by default             //a lean implementation of core jQuery designed specifically for the server             console.log($(\"title\").text());              const $bodyList = $(\"div.thumb_area\").children(\"div.thumb_box\");                          let newsList = [];             $bodyList.each(function(i, elem) {                 newsList[i] = $(this).find('a.thumb img').attr('alt');               });              console.log(newsList);         }         done();     } });   // Queue just one URL, with default callback c.queue('http://www.naver.com');   Reference     crawler   Node.js 에서 웹 크롤링하기   Naver  ","categories": ["Node.js"],
        "tags": ["Node.js","Crawling"],
        "url": "/nodejs/crawler/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "터미널로 AWS EC2 Linux 인스턴스 연결하기",
        "excerpt":"  AWS Console에 로그인할 필요 없이 터미널에서 AWS EC2 Linux 인스턴스에 연결하거나 파일을 전송하는 방법입니다.   단, 인스턴스를 생성할 때 설정한 프라이빗 키(.pem)가 있어야 합니다.     ssh로 인스턴스에 연결   ssh -i /path/my-key-pair.pem my-instance-user-name@my-instance-public-dns-name   scp로 인스턴스에 파일 전송   scp -i /path/my-key-pair.pem /path/SampleFile.txt my-instance-user-name@my-instance-public-dns-name:~   Reference     ssh 로 AWS EC2 접속하는 방법 &amp; scp 로 AWS EC2에 파일 전송하는 방법   SSH를 사용하여 Linux 인스턴스에 연결  ","categories": ["AWS"],
        "tags": ["AWS","EC2","ssh","scp"],
        "url": "/aws/ec2-connect/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "jQuery 설치 없이 사용하기[CDN]",
        "excerpt":"  여러 회사에서 제공하는 jQuery CDN을 이용하면 jQuery를 쉽고 빠르게 이용할 수 있습니다.     CDN (Content Delivery Network)   CDN은 인터넷 컨텐츠 (html, javascript 등)를 제공하기 위해 전세계에 분산되어 있는 서버입니다.   CDN을 이용하면 클라이언트(브라우저)는 가장 빠른 서버에서 데이터를 다운로드할 수 있습니다.   또한 CDN을 이용하면 jQuery와 같이 여러 웹페이지에서 동일하게 사용되는 코드들을 재사용할 수 있습니다.   jQuery CDN의 장점           서버 트래픽 감소 (jQuery를 서버에 설치할 필요가 없다.)            빠르다. (분산된 서버 사용, 중복 다운로드 최소화)       jQuery CDN 사용하기   간단 사용법(Google CDN)  &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\"&gt;&lt;/script&gt;  위의 html 태그를 jQuery를 사용하고자하는 웹페이지(html)에 추가해주기만 하면 됩니다. (2020/01/26 기준 최신버전 3.5.1)   사용법   jQuery 공식 다운로드 페이지에서 스크롤을 내려 Using jQuery with a CDN 항목을 찾습니다.      StackPath에서 제공하는 jQuery 공식 CDN이나 구글 등의 다른 회사에서 제공하는 CDN 중 원하는 것을 하나 선택합니다.   선택한 CDN 링크를 타고 들어가면 버전 별, jQuery CDN 사용 코드를 확인할 수 있습니다.   Reference     Downloading jQuery   What is a CDN?  ","categories": ["JavaScript"],
        "tags": ["JavaScript","jQuery","CDN"],
        "url": "/js/jquery-cdn/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "Riot API 사용법 - 계정 생성 & 소환사 정보 가져오기",
        "excerpt":"  리그오브레전드를 해봤다면 OP.GG, YOUR.GG 등 전적검색 사이트를 이용해본 경험이 있을 겁니다. 전적검색 사이트들은 Riot에서 제공하는 Riot API를 이용하여 유저들의 정보를 가져옵니다.   Riot API를 이용해서 저만의 롤 전적검색 사이트를 만들어 보려합니다.   이 포스팅에서는 Riot API의 기본적인 사용법을 살펴보고 간단히 테스트해보도록 하겠습니다.     계정생성  라이엇 개발자 페이지에 접속하여 본인의 롤 계정으로 로그인하거나 새 계정을 만들어줍니다.      로그인을 하면 약관 동의 화면이 나옵니다. 동의하면 라이엇 개발자 계정이 생성됩니다.      RIOT API KEY가 생성되었습니다. 지금 생성된 KEY는 DEVELOPMENT API KEY(개발용) 이므로 RATE LIMITS이 작게 설정되어있고, 공개 서비스에 사용할 수 없습니다. 공개서비스에 사용을 원한다면 API 신청을 하여 승인을 받아야합니다.      테스트   라이엇 개발자 페이지에서는 Riot API의 사용법을 알아보고 원하는 API를 간편하게 테스트해볼 수 있습니다.   소환사명으로 검색하기   페이지 상단의 API 탭으로 들어가서 SUMMONER-V4 항목을 선택하고, 두번째 항목인 by-name을 클릭해줍니다.      그러면 하단에 해당 API를 테스트해볼 수 있는 칸이 나옵니다. PATH PARAMETERS 탭의 summonerName 에 검색할 소환사의 이름을 입력하고 EXECUTE REQUEST 를 클릭합니다.   저는 Faker 선수의 소환사명인 Hide on bush를 검색해보겠습니다.      RESULT BODY 탭에서 API의 응답을 확인할 수 있습니다.   검색한 소환사의 id, accountId, puuid 를 얻었습니다. id, accountId의 경우 하나의 리전(KR)안에서만 고유한 값이고, puuid는 모든 리전에서의 고유한 값입니다.   그 외에도 소환사명, 레벨 등의 정보도 조회되었네요.    이 중에서 본인이 사용할 API가 요구하는 id값을 사용하면 됩니다. 주의할 사항은 API의 사용자가 바뀌면(KEY가 바뀌면) id값들도 바뀌게 됩니다. 즉, id값들은 하나의 API KEY만을 위해 암호화된 값들입니다. (API KEY를 재발급 받는 경우에는 바뀌지 않습니다) - 참조   소환사 리그 정보 조회하기 (티어, 승률 등)   LEAGUE-V4 탭에서 by-summoner 항목을 선택합니다.      마찬가지로 PATH PARAMETERS 탭에서 파라미터 값을 입력하고 EXECUTE REQUEST를 클릭해줍니다.   저는 위에서 조회했던 Hide on bush 소환사의 id를 검색해보았습니다.      RESPONSE BODY를 보면 티어, 승리 횟수, 패배 횟수 등의 현시즌 리그 정보를 확인할 수 있습니다.   Reference     DEVELOPER-RIOTGAMES   PUUIDs and Other IDs  ","categories": ["LoL"],
        "tags": ["Riot API","League of Legend"],
        "url": "/lol/riot-api/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "LoLog.me - 롤 전적검색 사이트",
        "excerpt":"  웹프로그래밍 공부할 겸, 롤 전전검색 사이트를 만들어봤습니다.   LoLog.me     GitHub Contribution Graph를 본따서 게임 플레이한 횟수를 그래프화해서 보여주는 웹사이트입니다.       처음에는 간단히 만들 생각이었지만 만들다보니 점점 욕심이 커지더군요… 추가하고 싶은 기능도 많아지고 디자인도 계속 신경쓰였습니다.         이것 저것 추가하다보니 지금 짜놓은 코드에서는 한계점도 보이기 시작했습니다. 그래서 이젠 제대로 만들어서 출시하기로 마음먹었습니다!   문제점  사실 이 웹사이트는 YOUR.GG 라는 사이트를 크롤링해서 정보를 가져옵니다. 라이엇 게임즈에서 제공하는 API를 이용해서 만들어야 하는 것이 맞지만 API KEY를 발급받는 것이 귀찮기도 하고 단순히 크롤링이 해보고 싶기도 해서 이렇게 만들었습니다 ㅠ   때문에 YOUR.GG 사이트가 코드를 바꾸거나 서버 ip를 차단이라도 해버리면 웹사이트가 작동을 하지 못하게 되겠죠. 웹서비스를 장기적으로 운영하기 위해서는 크롤링 코드를 폐기하고, Riot API를 이용하도록 코드 설계를 다시 해야합니다.   앞으로의 계획  이왕 이렇게 된거, 다시 처음부터 웹앱을 설계하려합니다! 코드를 짜면서 간간히 블로그에 포스팅도 하고, 어느정도 완성이 되면 일부 코드를 오픈소스화해보려 합니다. (누군가 기여를 해 주시길 바랍니다…)   Reference     LoLog.me   YOUR.GG  ","categories": ["LoL"],
        "tags": ["League of Legend","LoLog.me","Node.js"],
        "url": "/lol/lolog-me/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[Jekyll, GitHub Page] URL 변경 및 리다이렉트하기",
        "excerpt":"  제 블로그는 Jekyll과 GitHub Page 로 구현되어 있습니다. Jekyll의 기본설정에 따라, 포스트의 url이 /카테고리/타이틀로 설정 되어있었습니다. 이게 맘에 들지않아 url을 제 임의로 수정하고 기존의 url이 404 not found를 띄우지 않도록 Redirect했습니다.     Jekyll 포스트 url 변경하기  Jekyll 페이지의 url을 변경하는 방법은 간단합니다.  permalink: /my/url/  원하는 포스트에 permalink 변수를 추가해주시면 됩니다.   또는, 글로벌 변수를 수정하여 모든 포스트의 url의 형식을 한번에 바꾸는 방법도 있습니다. _config.yml 파일에  permalink: /:categories/:title/  이런 식으로 permalink 변수들을 사용하여 링크를 만들 수 있습니다. 사용할 수 있는 변수들은 지킬 공식 문서에 모두 나와있습니다. (Permalinks)   저는 개별 포스트마다 제가 원하는 링크를 설정해주었습니다.      기존 링크 Redirect  포스트 url을 바꿔버렸으니, 기존의 url로 접속시 404 Not Found 에러가 발생합니다.      이 블로그는 Google Search Console에 등록되어 있습니다. 아직 유입은 없지만 구글에 등록된 링크를 탔을 때에 404 Not Found 에러를 띄우고 싶지는 않았습니다. 그래서 기존의 링크를 새로운 링크로 Redirect하기로 했습니다.   301 Redirect  Redirect를 하는 가장 좋은 방법은 서버에서 301 redirect 응답을 해 주는 것입니다. 그러나 이 블로그는 정적 페이지 호스팅(Static Page Hosting)인 GitHub Page를 이용하고 있기 때문에 서버단에서의 301 리다이렉트 응답을 보낼 수 없습니다.   Plugin 사용  이 플러그인을 사용하면 리다이렉트 링크를 생성해준다고 합니다. 그러나 저는 리다이렉트해야할 링크가 몇개 없었기 때문에 굳이 플러그인을 사용하지 않았습니다.   Redirected Layout 사용하기  제가 사용한 방법입니다. 이곳을 참고했습니다.   먼저 redirected.html을 만들어서 _layout 폴더에 넣어줍니다.   &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=\"canonical\" href=\"\"/&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;meta http-equiv=\"refresh\" content=\"0;url=\" /&gt; &lt;/head&gt; &lt;body&gt;     &lt;h1&gt;Redirecting...&lt;/h1&gt;       &lt;a href=\"\"&gt;Click here if you are not redirected.&lt;a&gt;       &lt;script&gt;location=''&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  이 레이아웃은 canonical 태그를 최신 링크로 바꿔주고 refresh 메타 태그를 이용해 새로운 페이지로 redirect 시켜줍니다.   그리고 최상위 폴더에 redirect라는 폴더를 만든 뒤에 리다이렉트 링크를 하나씩 만들어줬습니다.  --- layout: redirected sitemap: false permalink: /coding/visual%20studio%20code/vscode-markdown/ redirect_to:  /vscode/markdown/ ---  permalink에 예전 링크를 넣고 redirect_to에 새로운 링크를 넣어줍니다. 그리고 블로그의 sitemap.xml에 예전 링크가 들어가지 않도록 sitemap은 false로 설정해줍니다.   리다이렉트가 필요한 링크마다 리다이렉트 링크를 만들어 주었습니다.      결과  이제 구글서치콘솔에 등록되어있는 포스트 링크로 접속했을 때에 새로운 페이지로 리다이렉트될 것입니다. 또한 시간이 지나면, 구글크롤링봇이 해당 페이지가 리다이렉트된 것을 파악하고 기존 링크로 만들어진 색인을 새로운 링크로 옮길 것입니다.   사실 refresh 메타 태그는 별로 추천되지 않는 방법이라고 합니다. 유저가 원하지 않는 링크로 이동시키고, 시간이 오래걸리기 때문이죠. 그러나 301 Redirect가 불가능할 때에는 최선의 방법이라고 생각되어 이 방법을 사용했습니다. 더 나은 방법을 찾으면 알려드리도록 하겠습니다.   Reference     Permalinks   How to redirect URLs on Jekyll site hosted on GitHub Pages   What is the best approach for redirection of old pages in Jekyll and GitHub Pages?   Google Warning: Using The Meta Refresh Tag Is Bad Practice  ","categories": ["Blog"],
        "tags": ["Jekyll","GitHub Page","Redirect","Permalink"],
        "url": "/blog/redirect/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "Riot API - Production API Key 발급받기(Register Product)",
        "excerpt":"  Riot API로 공개서비스를 제공하기 위해서는 제품을 등록하고, Production API Key를 발급받아야 합니다.     이전 포스트, LoLog.me - 롤 전적검색 사이트에서 계획한 대로 LoLog.me 웹서버를 Riot API를 사용하는 방식으로 변경하였습니다. YOUR.GG를 크롤링하던 코드를 모두 제거하고 Riot API 모듈을 만들어 적용시켰습니다.   현재는 이것저것 생각했던 기능을 추가해보고 있는 중입니다. 아직 웹서비스를 정식으로 출시할 단계는 아니지만, 제품이 승인되고 Production Key가 승인되기 까지 2주정도 시간이 걸린다고 하여 미리 신청해 두었습니다. (반려된다면 다시 신청해야겠죠 ㅠ)   계정생성 및 테스트  Riot API 사용법 - 계정 생성 &amp; 소환사 정보 가져오기 이전 포스팅에 자세히 설명해두었습니다.   제품 등록 - PRODUCT TYPE 선택하기  라이엇 개발자 페이지에 로그인하고 대쉬보드에서 REGISTER PRODUCT 버튼을 클릭합니다.   PRODUCT TYPE 선택화면에서 원하는 타입을 선택합니다.       PRODUCTION API KEY   공개 서비스를 제공할 때 필요한 API KEY입니다. Riot API를 이용한 어플리케이션이나 웹사이트를 제공하려할 때 선택합니다. 기본적으로 Rate Limit이 크게 설정되어 있고, 사용량이 많아지면 할당량 추가 신청을 할 수 있습니다. 제품 승인을 받고 API Key를 제공받기 위해서는 제품의 프로토타입과 웹사이트가 존재해야합니다.      PERSONAL API KEY   개발자 혼자 사용하거나 소규모 비공개 그룹을 위한 제품에 사용할 수 있는 API Key입니다. Rate Limit이 PRODUCTION API KEY에 비해 작게 설정되어 있고, 추가 할당량을 획들할 수 없습니다.   제품 등록 - 신청서 작성 &amp; 웹사이트 인증   원하는 PRODUCT TYPE을 선택하면 약관 동의 창이 뜹니다. 약관을 확인 후 동의하게 되면 신청서 작성 페이지가 열립니다. 저의 경우 웹사이트를 공개할 계획이기 때문에 PRODUCTION API KEY를 선택했습니다.   제품명, 제품 설명, 웹사이트 주소 등을 입력하고 제출하면 됩니다.   PRODUCTION API KEY를 선택한 경우, 접근 가능하고 본인이 관리할 수 있는 웹사이트를 제출해야 합니다. 제출 이후, 주어지는 코드를 /웹사이트.주소/riot.txt 경로에 올려 웹사이트를 인증하게 됩니다.   기다림…   신청서를 제출하고 웹사이트 승인을 끝마치면 이제 기다리는 일만 남았습니다. 유저 정보의 GROUPS 페이지에 들어가면, 신청한 앱의 간단한 정보를 확인할 수 있습니다. (자세한 정보는 APPS 페이지에 들어가면 확인할 수 있습니다.)      저는 아직 승인이 되지 않아 Pending 상태이고, API KEY가 발급되지 않았습니다.   2주정도 기다리면 Riot에서 제 신청서와 제품을 확인한 뒤에 승인여부를 결정하고 알려준다고 합니다.     신청결과  3-4일 뒤에 결과가 나왔고, 승인되었습니다 ㅎㅎ   관련 내용은 새로운 포스트로 올려두었습니다.      Riot API - Production API Key 승인!   Reference     DEVELOPER-RIOTGAMES   LoLog.me - 롤 전적검색 사이트   Riot API 사용법 - 계정 생성 &amp; 소환사 정보 가져오기  ","categories": ["LoL"],
        "tags": ["Riot API","LoLog.me","League of Legend"],
        "url": "/lol/production-key/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "Riot API - Production API Key 승인!",
        "excerpt":"  며칠전 신청했던 Riot API Production Key 발급이 승인되었습니다! 이제 LoLog.me 를 지속적으로 서비스할 수 있게 되었습니다.   신청서를 제출하고 승인이 되기까지 3-4일 정도 시간이 걸렸습니다. 생각보다 빠르게 돼서 놀랐네요 ㅎㅎ    이전 포스트          LoLog.me - 롤 전적검색 사이트            Riot API - Production API Key 발급받기(Register Product)       Riot API Production Key 승인   신청서를 제출한 이후로 서버에 올려둔 Development API Key가 만료되지 않도록 매일 라이엇 개발자 페이지에 들어가서 Key를 갱신해주고, 승인 여부를 확인했습니다.   며칠 뒤, 드디어 Pending 상태이던 저의 앱이 Approved 상태로 바뀌었고 API Key가 발급되었습니다!    Rate Limits도 10초에 500개, 10분에 30000개 요청으로 크게 늘었습니다. 추후에 이용자가 많아지게 되면 추가 할당량을 신청할 수 있다고 합니다.   Riot에서 이런 메시지도 왔습니다.    API Key도 승인을 받았으니, 이제 웹사이트를 하루빨리 완성하는 일만 남았습니다. 아직 갈길이 멉니다…ㅠ   Reference     DEVELOPER-RIOTGAMES   LoLog.me - 롤 전적검색 사이트   Riot API 사용법 - 계정 생성 &amp; 소환사 정보 가져오기   Riot API - Production API Key 발급받기(Register Product  ","categories": ["LoL"],
        "tags": ["Riot API","League of Legend"],
        "url": "/lol/production-key-approved/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "JavaScript 차트 만들기[Frappe Charts]",
        "excerpt":"  Frappe Charts는 SVG 차트를 쉽게 만들게 해주는 오픈소스 모듈입니다. 여러가지 종류의 깔끔한 그래프들을 간편하게 만들 수 있습니다.    CDN을 사용하여 설치하지 않고 사용하기  &lt;script src=\"https://cdn.jsdelivr.net/npm/frappe-charts@1.5.6/dist/frappe-charts.min.iife.js\"&gt;&lt;/script&gt;  해당 코드를 웹페이지의 head 태그 안에 삽입하면 CDN을 통해 Frappe Charts를 이용할 수 있습니다. 현재 기준으로는 1.5.6버전이 최신버전입니다.  GitHub Release에서 최신버전을 확인하시고 사용하시는 것을 추천합니다.   CDN에 대한 설명은 jQuery 관련 포스트를 참고하세요.     jQuery 설치 없이 사용하기[CDN]   차트 삽입  차트를 삽입할 위치에 div 태그를 추가하고 id를 설정해줍니다.  &lt;div id=\"chart\"&gt;&lt;/div&gt;  그리고 frappe.Chart() 함수를 사용해 차트를 생성해줍니다.  &lt;script&gt;     const data = {       labels: [                 '0min',  '1min',  '2min',  '3min',                 '4min',  '5min',  '6min',  '7min',                 '8min',  '9min',  '10min', '11min',                 '12min', '13min', '14min', '15min',                 '16min', '17min', '18min', '19min',                 '20min', '21min', '22min', '23min',                 '24min', '25min', '26min', '27min',                 '28min', '29min', '30min', '31min',                 '32min'               ],       datasets: [         {             name: \"Player 1\",             values: [               500, 0, 21, 199, 564, 275, 510,               340, 671, 549, 868, 66, 78, 410,               701,  971,  231, 646,  811, 1241,  99,               146,  712,  140, 485,  483,  711, 237,               410, 1089, 1460, 875, 1171             ]         },         {             name: \"Player 2\",             values: [               500,    0,  194,  548,  748, 1401,               149,  734, 1231,  214,  336,  949,               1681,  133,  364,  601, 1136,  253,               590,  112,  514,   11,  559,  376,               1214,   37,  544,  117,  719, 1249,               1438, 2007,  276             ]         }       ]     }                  const chart = new frappe.Chart(\"#chart\", {       title: \"Current Gold\",       data: data,       type: 'line', // 'bar', 'line', 'scatter', 'pie', 'percentage'       height: 250,       colors: ['#7cd6fd', '#743ee2']       lineOptions: {         hideDots: 1, // default: 0         regionFill: 1, // default: 0       }     }) &lt;/script&gt;  data 옵션을 통해 label과 datasets을 설정해줍니다.   그 외에 여러 옵션들을 수정하면서 원하는 그래프를 만들 수 있습니다.      Configuration      그래프 숨기기   Frappe Charts는 아직까지 유저가 원하는 데이터만을 보여주는 기능을 제공하지 않습니다. (제가 찾지 못한 것이라면 알려주세요 ㅠ)   CSS의 display 옵션을 이용해서 각각의 데이터를 보여주거나 없애는 토글 버튼을 만들었습니다.   먼저 default로 모든 그래프를 보이지 않게 설정해주었습니다. (head 태그에 추가)  &lt;style&gt;     .dataset-units {         display: none;     } &lt;/style&gt;   Hide() 함수를 만들어서 인자로 받은 dataset을 보여주거나 사라지게 했습니다. (head 태그에 추가)  &lt;script&gt;     function Hide(dataset) {         if(document.getElementsByClassName(dataset)style.display === 'block') {             document.getElementsByClassName(dataset)style.display = 'none';         } else {             document.getElementsByClassName(dataset)style.display = 'block';         }     } &lt;/script&gt;   마지막으로 body 태그에 각각의 데이터셋에 해당하는 버튼을 만들어줍니다.   &lt;button onclick=\"Hide('dataset-0')\"&gt;Player 1&lt;/button&gt; &lt;button onclick=\"Hide('dataset-1')\"&gt;Player 2&lt;/button&gt; &lt;button onclick=\"Hide('dataset-2')\"&gt;Player 3&lt;/button&gt;     히트맵, GitHub Contribution Graph   Frappe Charts는 히트맵 그래프 기능을 제공합니다. 이를 이용하면 GitHub의 Contribution Graph와 같은 그래프를 쉽게 만들 수 있습니다.      히트맵      LoLog.me 사이트를 만들 때, 사각형을 하나하나 찍는 코드를 짜서 비슷한 기능을 구현했었습니다. 이 모듈을 일찍 알았더라면 더 쉽게 구현할 수 있었을 듯 합니다…   완성된 코드 GitHub   &lt;!DOCTYPE html&gt; &lt;html lang=\"kr\"&gt;     &lt;head&gt;         &lt;meta charset=\"UTF-8\"&gt;         &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;         &lt;title&gt;Chart!&lt;/title&gt;          &lt;script src=\"https://cdn.jsdelivr.net/npm/frappe-charts@1.5.6/dist/frappe-charts.min.iife.js\"&gt;&lt;/script&gt;          &lt;style&gt;             .dataset-units {                 display: none;             }         &lt;/style&gt;          &lt;script&gt;             function Hide(dataset) {                 if(document.getElementsByClassName(dataset)[0].style.display === 'block') {                     document.getElementsByClassName(dataset)[0].style.display = 'none';                 } else {                     document.getElementsByClassName(dataset)[0].style.display = 'block';                 }             }         &lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;div id=\"chart\"&gt;&lt;/div&gt;                  &lt;script&gt;             const data = {                 labels: [                     '0min', '1min', '2min', '3min',                     '4min', '5min', '6min', '7min',                     '8min', '9min', '10min', '11min',                     '12min', '13min', '14min', '15min',                     '16min', '17min', '18min', '19min',                     '20min', '21min', '22min', '23min',                     '24min', '25min', '26min', '27min',                     '28min', '29min', '30min', '31min',                     '32min'                 ],                 datasets: [                     {                         name: \"Player 1\",                         values: [                             500, 0, 21, 199, 564, 275, 510,                             340, 671, 549, 868, 66, 78, 410,                             701, 971, 231, 646, 811, 1241, 99,                             146, 712, 140, 485, 483, 711, 237,                             410, 1089, 1460, 875, 1171                         ]                     },                     {                         name: \"Player 2\",                         values: [                             500, 0, 194, 548, 748, 1401,                             149, 734, 1231, 214, 336, 949,                             1681, 133, 364, 601, 1136, 253,                             590, 112, 514, 11, 559, 376,                             1214, 37, 544, 117, 719, 1249,                             1438, 2007, 276                         ]                     },                     {                         name: \"Player 3\",                         values: [                             500, 0, 63, 395, 753, 1474,                             1845, 55, 111, 544, 865, 344,                             394, 735, 1038, 1432, 40, 458,                             1057, 276, 399, 770, 1313, 490,                             904, 22, 215, 543, 257, 797,                             954, 1536, 1992                         ]                     }                 ]             }              const chart = new frappe.Chart(\"#chart\", {  // or a DOM element,                 // new Chart() in case of ES6 module with above usage                 title: \"Current Gold\",                 data: data,                 type: 'line', // or 'bar', 'line', 'scatter', 'pie', 'percentage'                 height: 250,                 //colors: ['#7cd6fd', '#743ee2']                 lineOptions: {                     hideDots: 1, // default: 0                     regionFill: 1, // default: 0                 }             })         &lt;/script&gt;          &lt;button onclick=\"Hide('dataset-0')\"&gt;Player 1&lt;/button&gt;         &lt;button onclick=\"Hide('dataset-1')\"&gt;Player 2&lt;/button&gt;         &lt;button onclick=\"Hide('dataset-2')\"&gt;Player 3&lt;/button&gt;     &lt;/body&gt; &lt;/html&gt;   Reference     Frappe Charts - Docs   jQuery 설치 없이 사용하기[CDN]  ","categories": ["JavaScript"],
        "tags": ["JavaScript","Frappe Charts"],
        "url": "/js/frappe-charts/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "MySQL INSERT 한번에 하기 (성능 대폭 향상)",
        "excerpt":"  MySQL에서 여러개의 INSERT 쿼리를 통합시켜 하나의 쿼리문으로 만들면 성능이 대폭 향상됩니다. (하나의 table에 대한 쿼리문일 경우)    MySQL INSERT 쿼리 문법  INSERT INTO tbl_name (a,b,c)     VALUES(1,2,3), (4,5,6), (7,8,9);   성능 테스트 (LoLog.me)   Riot API는 플레이어의 게임 데이터를 100경기씩 반환해줍니다. LoLog.me 의 웹서버는 1년치 게임 데이터를 가져와 하나씩 DB에 저장합니다. 게임 하나마다 INSERT 쿼리를 전송할 경우, 유저의 게임 플레이 횟수가 많아질수록 로드가 매우 커지게 됩니다.      위는 페이커 선수의 최근 1년 게임데이터를 가져오면서 찍은 로그입니다. Riot API로 게임데이터를 가져온 후로 부터 DB에 게임데이터를 모두 INSERT하고 다시 데이터를 가져오기까지 걸리는 시간을 측정했습니다.   총 1800경기를 DB에 INSERT하고, SELECT문을 통해 다시 가져오기까지 걸리는 시간은 대략 12초 정도 였습니다. 웹사이트에서 검색 결과를 기다리기에는 너무 큰 시간입니다.   INSERT 쿼리를 게임 단위에서 Riot API 단위(최대 100경기) 로 변경한 결과,      동일한 일을 처리하는데 걸리는 시간이 74ms로 측정되었습니다… 엄청난 수치의 성능향상입니다. 전송되는 쿼리의 갯수는 1/100로 줄었지만 쿼리 하나 하나의 처리량이 많아졌기 때문에 100배의 성능향상을 기대하지도 않았습니다. 그러나 무슨이유에서인지 100배 이상의 성능향상이 있었습니다.   가설   곰곰이 생각해본 결과 제가 생각해낸 원인은 INDEX 입니다. 저는 게임데이터에서 user_id와 timestamp(게임시작시간)을 결합하여 INDEX를 만들고, 이를 PRIMARY KEY 로 설정했습니다. 그래서 게임데이터가 하나씩 INSERT 될 때마다 INDEX가 업데이트 되고, 같은 user_id를 가진 데이터가 늘어남에 따라 INSERT 쿼리를 처리하는 데에 걸리는 시간이 점점 늘어나게 되는 것입니다.   이는 그저 저의 추측일 뿐이며, 구체적인 알고리즘은 저도 알지 못합니다. 정확한 원인을 알고 계신 분이 있다면 알려주세요 ㅎㅎ   조만간 DB를 제대로 공부해볼 계획입니다. DB와 MySQL을 공부하다보면 정확한 원인을 찾을 수 있겠지요. 오늘은 일단 여기까지하고 쉬어야겠습니다… 뭔가 찾으면 다시 포스팅 하겠습니다.   Reference     13.2.6 INSERT Statement    추가1   참고할 만한 자료     BULK INSERTING - MYSQL 다량의 데이터 넣기   추가2   INSERT 쿼리가 처리되기 전에 SELECT 쿼리를 전송한 것이 성능을 저하시킬 수도 있다는 생각이 들었습니다. 이부분도 고려하여 좀 더 공부해보아야겠습니다.  ","categories": ["MySQL"],
        "tags": ["MySQL","Database","LoLog.me"],
        "url": "/mysql/insert-multi/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "AWS EC2 서버 터짐... (서버 재부팅, 경보 설정)",
        "excerpt":"  밤사이 저의 AWS EC2 서버가 터졌습니다. 아쉽게도 사용자가 많아 터진 것은 아니었습니다… ㅎ       그래프에서 초록색 선이 CPU 사용량(CPU Utilization)이고, 주황색 선이 보유 크레딧 개수(CPU Credit Balance) 입니다. 태평양표준시(UTC) 기준 15시부터 18시 사이에 CPU 사용량이 100%로 유지되었고, 그 이후 크레딧이 모두 소진되어 10%의 사용량이 유지되었습니다.(크레딧을 소진하지 않는 최대 사용량이 10%인 것 같습니다) 그리고 다음날 3시쯤, 제가 이 사실을 발견하고 서버를 재부팅하여 다시 CPU 사용량이 줄어들고 크레딧이 늘어나기 시작했습니다.   서버 재부팅   서버가 터진 사실을 발견했을 당시, AWS EC2 서버가 풀가동되고 있는 상태였기 때문에 AWS Console에서 EC2 인스턴스에 연결할 수 없었습니다. 그래서 어떤 작업이 CPU를 사용하고 있는지 모니터링할 수 없었고, 서버를 재부팅해야했습니다. AWS Console의 EC2 관리 페이지에서 재부팅을 쉽게 할 수 있습니다.   원인파악   당시에 앵무새봇은 작동하지 않는 상태였고, LoLog.me 페이지는 정상적으로 작동하고 있었습니다. 또한 앵무새봇의 로그에서 음악을 재생한 로그는 찍혔지만 음악이 끝난 로그는 찍히지 않았고, 그 시점이 서버가 과부하된 시점과 일치했기에 앵무새봇의 문제라고 판단했습니다. 아마 유튜브로 음악을 스트리밍해주는데 사용한 ytdl-core-discord 모듈의 버그로 보입니다.   AWS CloudWatch 경보 설정 (Alert)   정확한 원인을 찾고 이를 해결하지는 못했지만, 다시 비슷한 문제가 발생했을 때, 서비스가 몇시간동안 중지되고 이를 제가 파악하지 못하는 일이 반복되지 않도록 AWS CloudWatch의 경보 기능을 활성화시켰습니다.   AWS Console에서 CloudWatch -&gt; 경보 탭에 들어가면 경보를 생성할 수 있습니다. EC2 뿐만 아니라 RDS나 다른 AWS 서버들의 모니터링 지표를 기준으로, 기준치가 초과되었을 경우 메일을 보내주거나 간단한 작업을 수행시킬 수 있습니다.      저는 CPU 사용량이 15%가 넘을 경우 저에게 메일이 발송되도록 설정했고, 50%를 초과할 경우에는 서버가 자동으로 재부팅되도록 설정했습니다.   이제 동일한 문제가 발생했을 때에, 상황을 빠르게 인지하고 서버가 오랜 시간 동안 과부하되는 일을 방지할 수 있게 되었습니다.   추가로 해야할 일          정확한 원인을 파악하고 코드를 수정할 것(ytdl-core-discord 모듈의 문제라면, GitHub에 이슈를 띄울 것)            서버가 자동으로 재부팅되면 실행되던 앱들이 종료되므로, 자동으로 앱을 실행시키는 방법을 찾을 것      ","categories": ["AWS"],
        "tags": ["AWS","EC2"],
        "url": "/aws/ec2-alert/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "JavaScript 도넛 차트 만들기[Google Charts]",
        "excerpt":"  Google Charts는 예전에 포스팅했던 Frappe Charts와 비슷한 기능을 하는 자바스크립트 차트 라이브러리입니다. 사용법도 거의 비슷하고, 구글에서 만든 모듈인지라 문서화가 잘 돼있습니다. Google Charts    JavaScript 차트 라이브러리           Frappe Charts            Google Charts            Charts.js       세 라이브러리 모두 도넛차트를 지원합니다. 원하는 디자인이나 기능을 따져보고 사용할 라이브러리를 선택하시면 됩니다.   Google Charts 설정 및 파이차트 생성   Quick Start   &lt;html&gt;   &lt;head&gt;     &lt;!--Load the AJAX API--&gt;     &lt;script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"&gt;&lt;/script&gt;     &lt;script type=\"text/javascript\"&gt;        // Load the Visualization API and the corechart package.       google.charts.load('current', {'packages':['corechart']});        // Set a callback to run when the Google Visualization API is loaded.       google.charts.setOnLoadCallback(drawChart);        // Callback that creates and populates a data table,       // instantiates the pie chart, passes in the data and       // draws it.       function drawChart() {          // Create the data table.         var data = new google.visualization.DataTable();         data.addColumn('string', 'Topping');         data.addColumn('number', 'Slices');         data.addRows([           ['Mushrooms', 3],           ['Onions', 1],           ['Olives', 1],           ['Zucchini', 1],           ['Pepperoni', 2]         ]);          // Set chart options         var options = {'title':'How Much Pizza I Ate Last Night',                        'width':400,                        'height':300};          // Instantiate and draw our chart, passing in some options.         var chart = new google.visualization.PieChart(document.getElementById('chart_div'));         chart.draw(data, options);       }     &lt;/script&gt;   &lt;/head&gt;    &lt;body&gt;     &lt;!--Div that will hold the pie chart--&gt;     &lt;div id=\"chart_div\"&gt;&lt;/div&gt;   &lt;/body&gt; &lt;/html&gt;   파이차트를 도넛차트로   파이차트에 pieHole 옵션을 추가해주면 파이차트의 중앙에 구멍이 생겨 도넛차트가 됩니다.   var options = {       pieHole: 0.41     }   커스터마이징  여러가지 옵션을 주면서 차트를 커스터마이징합니다.      Configuration Options   var options = {   pieHole: 0.41,  // 도넛차트   chartArea: {     /* 차트크기 */     width: 200,     height: 200     },    /* 전체크기 */   width: 300,   height: 300,    /* 배경색 설정 */   backgroundColor: 'whitesmoke',    /* 차트에 레이블 표시 (percentage, value or label)*/   pieSliceText: 'label',    /* 꼬리표 제거 */   legend: 'none' };   도넛차트 중앙에 이미지 추가  CSS의 position 속성(relative, absolute)를 이용합니다. 차트와 이미지를 감싸는 부모 &lt;div&gt; 태그에 position: relative;, 이미지 태그에 position: absolute;의 CSS 설정을 해준 뒤에 위치를 조정하면 됩니다.   #container {     position: relative; }  #piechart {     width: 900px;     height: 500px; }  #overlay {     position: absolute;     width: 80px;     height: 80px;     top: 110px;     left: 110px;     border-radius: 40px; }   완성된 코드 GitHub   &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;차트테스트&lt;/title&gt;         &lt;meta charset=\"utf-8\"&gt;         &lt;script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"&gt;&lt;/script&gt;     &lt;style&gt;       #container{         position: relative;       }        #piechart{width: 900px; height: 500px;}        #overlay {         position: absolute;         width: 80px;         height: 80px;         top: 110px;         left: 110px;         border-radius: 40px;       }     &lt;/style&gt;          &lt;script type=\"text/javascript\"&gt;       google.charts.load('current', {'packages':['corechart']});       google.charts.setOnLoadCallback(drawChart);        function drawChart() {          var data = google.visualization.arrayToDataTable([           ['Task', 'Hours per Day'],           ['Work',     11],           ['Eat',      2],           ['Commute',  2],           ['Watch TV', 2],           ['Sleep',    7]         ]);          var options = {           pieHole: 0.41,  // 도넛차트           chartArea: {             /* 차트크기 */             width: 200,             height: 200           },           /* 전체크기 */           width: 300,           height: 300,            /* 차트에 레이블 표시 (percentage, value or label)*/           pieSliceText: 'label',            /* 꼬리표 제거 */           legend: 'none'         };          var chart = new google.visualization.PieChart(document.getElementById('piechart'));          chart.draw(data, options);           }     &lt;/script&gt;              &lt;/head&gt;     &lt;body&gt;       &lt;div id=\"container\"&gt;         &lt;div id=\"piechart\"&gt;&lt;/div&gt;         &lt;img id=\"overlay\" src=\"https://ddragon.leagueoflegends.com/cdn/11.4.1/img/champion/Shen.png\"&gt;       &lt;/div&gt;     &lt;/body&gt; &lt;/html&gt;   Reference           Google Charts            CSS position 속성으로 div 위에 div 겹치기      ","categories": ["JavaScript"],
        "tags": ["JavaScript","Google Charts"],
        "url": "/js/charts-donut/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "Riot API Match-V4, matchHistoryUri가 뭘까?",
        "excerpt":"  Riot API의 Match-V4의 리턴값 중에서 PlayerDto 안에 ‘matchHistoryUri’라는 값이 있습니다. 이 값을 어디에 사용할 수 있을까요?     발견  LoLog.me 사이트에 전적 정보를 제공하기 위해 Riot API의 Match-V4를 살펴보던 중 ‘matchHistoryUri’라는 값을 발견했습니다.  {   \"participantId\": 7,   \"player\": {       \"platformId\": \"KR\",       \"accountId\": \"hFlkJJh8PyYwQlyagva_cVk2-87VL4UGzwNjV9v0u-QB1lw\",       \"summonerName\": \"유년이\",       \"summonerId\": \"rs841I4dVrVYnXe1NsawNrm8nJJ9vUsI5QUdLkk99ZwzwaI\",       \"currentPlatformId\": \"KR\",       \"currentAccountId\": \"hFlkJJh8PyYwQlyagva_cVk2-87VL4UGzwNjV9v0u-QB1lw\",       \"matchHistoryUri\": \"/v1/stats/player_history/KR/206932210\",  // ???       \"profileIcon\": 4594   } },  제가 필요한 기능이 Match History를 가져오는 것이었기 때문에 matchHistoryUri의 정체가 뭔지 알고 싶었습니다.   정체가 뭐냐  라이엇 개발자 페이지를 뒤져봤지만 관련된 정보를 찾을 수 없었고 구글에 검색해도 제대로된 자료를 찾기 어려웠습니다.   일단 https://acs.leagueoflegends.com에 matchHistoryUri를 붙여넣으면 플레이어의 최근 10개의 전적을 볼 수 있다는 것을 알아냈습니다.   https://acs.leagueoflegends.com/v1/stats/player_history/KR/206932210   그러나 이 데이터가 라이엇에서 공식적으로 제공하는 데이터인지 알 수 없었고, 이것을 웹서비스에 이용해도 되는지도 알 수 없었습니다. 그리고 Riot 계정으로 로그인하지 않은 상태에서는 데이터를 요청할 수 없는 문제도 있었습니다.   디스코드 채널에서 답을 찾다   명확한 해답을 찾기 위해 라이엇 API 공식 디스코드 채널에 가입했습니다. 디스코드 채널에서 matchHistoryUri라는 키워드로 검색해보니 저와 비슷한 궁금증을 가진 사람들이 많았습니다. 그리고 이에 대한 해답을 얻을 수 있었습니다.      일단, ACS는 웹서비스에 이용하면 안됩니다. 이유는 세가지가 있습니다.     Rate Limit을 알 수 없다. (안정적인 서비스 불가능)   암호화되지 않은 ID를 제공한다. (Riot API는 사용자별로 다르게 암호화된 ID를 사용합니다. 따라서 ACS와 API를 혼합해서 사용하기 어려울 것입니다.)   문제가 생기면 해결하기 어렵다.(?) (아마 ACS가 공식적으로 제공하는 기능이 아니기 때문에 issue 해결하는데 어렵다는 말 같습니다.)   결론  결론은 “사용하지 않는 것” 이 답입니다. 현재 라이엇에서 정식으로 제공하는 기능도 아니며, 활용하기도 어려울 것입니다.   전적 10개를 한번에 가져오는 기능은 현재 Match-V4 API에서 제공하지 않습니다. 여러개의 전적 데이터를 가져오기 위해서는 Match-V4 API를 여러번 동시에 호출하는 것이 현재로써는 최선의 방법으로 보여집니다.   LoLog.me에서는 현재 개별 매치 데이터를 제공하고 있지 않습니다. (라이엇 공식 사이트로 연결해줍니다.) 하루빨리 개별 전적 데이터 제공 및 저장 기능을 구현해야겠습니다. (데이터가 워낙 많아 API와 DB를 적절히 활용하는 최적의 방법을 찾아야 합니다..!)   Reference          DEVELOPER-RIOTGAMES            The New Match History      ","categories": ["LoL"],
        "tags": ["Riot API","League of Legend","LoLog.me"],
        "url": "/lol/riot-matchhistoryuri/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[LoLog.me] 한달간 업데이트 내역",
        "excerpt":"  LoLog.me 사이트를 제대로 만들어 보겠다는 포스트를 업로드한 후로 딱 한달이 지났습니다. 그동안 업데이트한 내용들을 정리해볼까 합니다.    Preview  LoLog.me   메인 페이지           Before             After        User 페이지           Before             After        모바일 페이지      Before           After        Riot API Production Key 승인  먼저 계획했던 대로 Riot API를 이용해 사이트가 동작하도록 웹앱의 코드를 전체적으로 리팩토링했습니다. Riot API가 생각보다 응답속도가 굉장히 빠릅니다. (체감상 디스코드봇을 만들 때 사용했던 YouTube API보다 빠른 것 같았습니다) 그리고 Node.js의 특성상 병렬적으로 API를 호출하고 데이터를 처리하기 수월했습니다. 그 결과, 크롤링을 사용해서 데이터를 가져왔을 때보다 사이트의 응답속도가 몇배는 더 빨라졌습니다.   리팩토링을 마친 후에 Riot API Production Key를 신청하고 승인받았습니다. 이제 정식으로 Riot API를 사용하여 웹서비스를 제공할 수 있게 된 것입니다.   Riot API 관련 포스트          Riot API 사용법 - 계정 생성 &amp; 소환사 정보 가져오기            Riot API - Production API Key 발급받기(Register Product)            Riot API - Production API Key 승인!            Riot API Match-V4, matchHistoryUri가 뭘까?       상세 검색 옵션 추가          지역 설정을 변경할 수 있고, 리그오브레전드가 서비스하는 모든 지역의 소환사 정보를 조회할 수 있습니다.            시즌별, 기간별로 전적 기록을 조회할 수 있습니다.            포지션별, 챔피언별로 전적 기록을 조회할 수 있습니다.            기존에 지원하던 솔랭, 자랭 등의 게임 모드별 검색 기능에서, 이제 모든 게임모드를 조회 가능합니다.       DB 연동  Riot API를 이용해서 전적 로그를 가져오기 위해서는 100 게임당 1개의 API 호출이 필요합니다. 유저 한명당 1000게임 이상의 전적 로그를 한번에 가져와야할 경우가 많아서 매번 API를 호출할 경우 Riot API의 Rate Limit에 금방 도달해버릴 것입니다. 또한 사이트 로딩 속도도 느려지겠죠.   그래서 API를 통해 가져온 유저 데이터 및 전적 로그 데이터를 DB에 저장해두었습니다. 동일한 유저를 검색했을 때에는 API를 호출하지 않고 DB에서 빠르게 데이터를 가져옵니다. DB서버는 AWS RDS MySQL 서버를 이용중입니다. (AWS 프리티어 기간이라 EC2와 함께 무료로 이용중입니다)   현재까지는 DB 응답이 빠르게 잘 이루어지고 있습니다. 현재 유저 41명 기준 약 6MB 정도의 용량을 차지하고 있고, 유저가 늘어날 경우에도 잘 작동할 지는 지켜봐야할 것 같습니다.   MySQL 관련 포스트     MySQL INSERT 한번에 하기 (성능 대폭 향상)   포지션별, 챔피언별 도넛차트 추가  유저별로 수많은 게임 로그 데이터를 어떻게 시각화하면 흥미로울 지를 고민하였습니다. 롤에서 가장 중요한 포지션(라인)과 챔피언에 관한 정보를 차트로 보여주고 싶었습니다. 이제 선택한 기간 동안에 플레이한 포지션과 챔피언의 비율을 도넛차트로 한눈에 확인할 수 있습니다. 특정 포지션을 선택할 경우, 해당 포지션으로 플레이한 챔피언의 비율도 확인해볼 수 있습니다.   차트는 Google Charts 라이브러리를 이용해서 구현했습니다. 공개된 라이브러리를 잘 활용하는 것도 개발자의 중요한 스킬인 것 같습니다. 라이브러리를 잘 이해하고 활용하면 개발 효율이 훨씬 상승합니다!   차트 관련 포스트     JavaScript 차트 만들기[Frappe Charts] (롤로그미에 Frappe Charts를 활용하지는 않았습니다.)   JavaScript 도넛 차트 만들기[Google Charts]   UI 대폭 변경          메인페이지 배경색 변경            로고 글씨체 변경 (상업적으로 이용 가능한 무료폰트: Bombardier)            Favicon 추가 (브라우저 탭에 뜨는 작은 아이콘, 참고 사이트: Favicon Generator)            Footer 추가 (사이트 맨 아래 문구)            그외 여러 디자인 (검색창, 버튼, 로그 숨기기 등)       여러 브라우저에 대응하려다보니 까다로운 부분이 많았습니다. 일단 데스크탑 기준 크롬, 사파리, 엣지, 파이어폭스를 지원하고 모바일 기준 크롬, 사파리를 지원합니다. 이렇게 되면 90% 이상의 유저를 지원하게 됩니다!   다국어 지원  아직 다국어라하기에는 좀 무리가 있지만, 현재 한국어와 영어를 지원합니다. npm의 i18n 모듈을 이용했습니다.   향후 계획  이상하게 업데이트를 하면 할수록 할일이 더 많아집니다… 아직 수정해야할 부분도 많은데 추가하고 싶은 기능과 서비스가 점점 많아지고 있습니다.   패치가 필요한 부분          모바일에서 도넛차트가 너무 크게 보입니다.            현재 소환사를 검색하면 1년치 데이터가 기본값으 조회됩니다. 모바일 기기는 데스크탑만큼 성능이 좋지 않습니다. 모바일 기기에서 검색할 시에는 조회 기간을 더 짧게 설정하여 페이지 로딩 속도를 향상시켜야할 필요가 있습니다.            다국어 지원은 하지만 접속 지역에 따라서 리그오브레전드 서버 지역이 자동으로 바뀌지 않습니다. 현재는 한국서버가 검색 기본값으로 항상 선택되어 있습니다. 지역에 따라서 언어가 바뀌듯이 검색 지역 또한 자동으로 설정되도록 해야합니다.       추가하고 싶은 기능          전적 상세 정보 - 전적에 대한 상세 정보를 보여주고 싶습니다. 그러나 전적 상세 정보는 1 게임당 1번의 API 호출이 필요합니다. 그래서 상위 몇개의 전적에 한해서만 상세 정보를 제공해야할 것입니다. 또한 전적 상세 정보를 DB에 저장하게 될 경우 용량을 훨씬 더 차지할 것입니다. 이를 어떻게 해결할 지도 생각해 보아야 합니다.            정글 동선 분석 - 여러 유저들의 게임 플레이 기록을 분석하여 정글 챔피언별로 효과적인 정글 동선을 분석해보고 싶습니다. 정글 동선은 정글러에게 있어서 가장 중요한 부분입니다. 이를 데이터에 기반하여 분석하면 유용한 데이터를 만들어낼 수 있을 것 같습니다. (제가 정글러라서 저에게도 큰 도움이 될 겁니다!)            구글 애드센스 - 구글 애드센스를 신청했으나 반려되었습니다. 아직은 부족한 부분이 많은 것 같습니다. 상세 전적 기능까지 구현한 뒤에 다시 신청해볼 계획입니다.       Reference          LoLog.me            LoLog.me - 롤 전적검색 사이트            Riot API 사용법 - 계정 생성 &amp; 소환사 정보 가져오기            Riot API - Production API Key 발급받기(Register Product)            Riot API - Production API Key 승인!            Riot API Match-V4, matchHistoryUri가 뭘까?            MySQL INSERT 한번에 하기 (성능 대폭 향상)            JavaScript 차트 만들기[Frappe Charts]            JavaScript 도넛 차트 만들기[Google Charts]            Google Charts            Bombardier            Favicon Generator            i18n      ","categories": ["LoL"],
        "tags": ["League of Legend","LoLog.me","Node.js"],
        "url": "/lol/lolog-monthly/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "Visual Studio Code 자주 사용하는 단축키 모음",
        "excerpt":"  VS Code 에서 제가 많이 사용하는 단축키들입니다.    되돌리기: ctrl + z   복사: ctrl + c  블록설정을 하지 않고 복사할 경우, 줄 전체가 복사됩니다.   잘라내기: ctrl + x  블록설정을 하지 않고 잘라낼 경우, 줄 전체가 잘라내어 집니다.   붙여넣기: ctrl + v   검색: ctrl + f  커서 위치의 단어를 검색합니다.   들여쓰기: ctrl + ]  커서위치의 줄 또는 블럭설정된 문단 전체를 들여쓰기합니다. (커서가 줄 맨앞에 있거나, 블럭설정된 상태에서는 tab키와 동일한 기능을 합니다)   내어쓰기: ctrl + [  커서위치의 줄 또는 블럭설정된 문단 전체를 내어쓰기합니다.(한칸씩 당깁니다)   줄 복사     아래로 복사: shift + alt + ↑   위로 복사: shitf + alt + ↓   커서위치의 줄 또는 블럭설정된 문단 전체를 복사합니다.   블럭설정          한글자씩: shift + 방향키            한단어씩: shift + ctrl + 방향키       다중 커서 (마우스): alt + click  클릭한 위치에 커서가 추가로 생성됩니다.   다중 커서 (키보드)     ctrl + alt + ↑   ctrl + alt + ↓   윗줄이나 아랫줄의 동일한 위치에 커서를 추가로 생성합니다.   주석 처리: ctrl + k ctrl + c  ctrl을 누른 상태에서 k와 c를 순서대로 누릅니다.   커서위치의 줄 또는 블록설정된 문단 전체를 주석처리합니다.   주석 처리 취소: ctrl + k ctrl + u  ctrl을 누른 상태에서 k와 u를 순서대로 누릅니다.   주석처리된 커서위치의 줄 또는 블록설정된 문단전체의 주석 처리를 취소합니다.   동일한 단어 선택: ctrl + d  커서 위치의 단어와 동일한 단어를 찾아서 선택합니다. 한번 누를 때마다 아래쪽의 동일한 단어가 하나씩 추가로 선택됩니다.   패널(터미널) 열기 &amp; 닫기: ctrl + j  아래쪽 패널을 열고 닫습니다. 터미널의 디폴트 위치가 현재 열려있는 폴더로 설정돼서, 프로그램을 작성하고 테스트해볼 때 매우 유용합니다.   사이드바 열기 &amp; 닫기: ctrl + b  왼쪽의 사이드바를 열고 닫습니다. 화면을 분할해서 작업할 때, 에디터 화면을 크게 볼 수 있어서 유용합니다.   전체화면: f11  브라우저의 전체화면과 비슷하게 작업표시줄과 메뉴바를 숨깁니다.   Markdown 미리보기: ctrl + k v  ctrl + k를 누르고 v를 누르면, 화면이 분할되고 오른쪽에 미리보기 창이 열립니다.     참고 포스트: Visual Studio Code에서 Markdown(.md) 미리보기   키보드 단축키 설정창: ctrl + k ctrl + s  ctrl을 누른 상태에서 k와 s를 순서대로 누르면 키보드 단축키를 확인하고 설정할 수 있는 창이 열립니다.   내가 설정해놓은 단축키     Activity Bar는 왼쪽 끝의 아이콘 패널입니다. Minimap은 오른쪽 끝에 있는, 코드 전체를 한눈에 보여주는 패널 입니다. 이 두개의 패널은 항상 열려있지만 키보드 단축키 설정창에서 토글키를 설정해주면 숨길 수 있습니다. 노트북으로 작업할 때에 화면이 부족해서 답답한 경우에 전체화면에서 양옆의 패널까지 모두 숨겨주면 훨씬 쾌적하게 작업할 수 있습니다.   Reference     Visual Studio Code에서 Markdown(.md) 미리보기  ","categories": ["Visual Studio Code"],
        "tags": ["Visual Studio Code","Shortcut"],
        "url": "/vscode/shortcuts/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "Express 웹사이트 보안 강화하기 [Helmet, CSP]",
        "excerpt":"  Express로 만들어진 웹 사이트의 보안을 강화하기 위해 Helmet 미들웨어를 사용합니다.    설치 및 사용법          Helmet            Production Best Practices: Security       $ npm install helmet --save   // ...  const helmet = require('helmet')  // 모든 기능 사용 app.use(helmet());  // or, 특정 기능 사용 app.use(helmet.contentSecurityPolicy()); app.use(helmet.dnsPrefetchControl()); app.use(helmet.expectCt()); app.use(helmet.frameguard()); app.use(helmet.hidePoweredBy()); app.use(helmet.hsts()); app.use(helmet.ieNoOpen()); app.use(helmet.noSniff()); app.use(helmet.permittedCrossDomainPolicies()); app.use(helmet.referrerPolicy()); app.use(helmet.xssFilter());  // ...   Content Security Policy (CSP)  CSP를 사용하면 웹사이트의 http응답에 CSP 헤더가 추가됩니다. CSP 헤더가 존재할 경우, 브라우저는 CSP 헤더에 언급되지 않은 리소스들을 로드하지 않습니다. Helmet의 CSP 기본설정은 ‘self’ 즉, 자신의 웹사이트에 존재하는 리소스들만을 허용합니다.    (CSP로 인해 리소스를 가져오지 못한 웹페이지 LoLog.me)   그래서 CDN 등의 외부 사이트의 소스를 이용할 경우, 또는 다른 웹사이트에서 이미지 로드하는 경우, 심지어 인라인 스크립트로 자바스크립트 코드를 작성한 경우 모두 에러를 발생시킵니다. 이를 해결하기 위해서는 웹 페이지가 사용할 신뢰할 수 있는 리소스들의 도메인을 CSP 헤더에 추가해야합니다.   const cspOptions = {   directives: {     // 기본 옵션을 가져옵니다.     ...helmet.contentSecurityPolicy.getDefaultDirectives(),          // 구글 API 도메인과 인라인된 스크립트를 허용합니다.     \"script-src\": [\"'self'\", \"*.googleapis.com\", \"'unsafe-inline'\"],      // 리그오브레전드 사이트의 이미지 소스를 허용합니다.     \"img-src\": [\"'self'\", \"data:\", \"*.leagueoflegends.com\"],   } }  // Helmet의 모든 기능 사용. (contentSecurityPolicy에는 custom option 적용) app.use(helmet({   contentSecurityPolicy: cspOptions, }));   ‘unsafe-inline’ 대체하기  CSP 헤더에 ‘unsafe-inline’을 추가하면, 인라인된 스크립트의 실행이 허용됩니다. 그러나 이는 해커가 웹사이트의 inline 스크립트를 주입하여 보안상의 위협을 가할 수 있게 합니다. 이를 해결하는 방법은 세가지가 있습니다.   1. inline script 없애기  기존에 작성했던 인라인 스크립트를 개별 파일로 옮기고, js 파일 자체를 script 태그의 src 속성으로 추가하면 됩니다. onclick 속성과 같이, 태그 내부에서 자바스크립트를 실행하는 속성들은 js 파일에서 addEventListener() 함수로 대체할 수 있습니다.   &lt;button id=\"btn\" onclick=\"doSomething()\"&gt;  버튼 태그의 onclick 속성을  document.getElementById(\"btn\").addEventListener('click', doSomething);  // jQuery 이용시 $('#btn').click(dosomething);  addEventListener() 함수를 호출함으로써 대체할 수 있습니다. (또는 jQuery 이용)   2. nonce 속성 이용  웹페이지를 로드할 때마다 무작위로 생성된 nonce 속성을 인라인 스크립트에 부여하고, 이를 CSP 헤더에 추가합니다. 응답(response) 마다 다른 nonce 값이 설정되므로, 제 3자가 인라인 스크립트를 주입하기 어려워집니다.   Express에서 nonce 생성 및 사용 예제  // nonce 생성 app.use((req, res, next) =&gt; {   res.locals.cspNonce = crypto.randomBytes(16).toString(\"hex\");   next(); });  // helmet 설정 예 app.use(   helmet.contentSecurityPolicy({     directives: {       defaultSrc: [\"'self'\"],       scriptSrc: [\"'self'\", (req, res) =&gt; `'nonce-${res.locals.cspNonce}'`]     },   }) );   HTML에서 script 태그에 nonce 속성 추가  &lt;script nonce=\"{cspNonce Value}\"&gt;   alert('Hi'); &lt;/script&gt;  3. hash 사용  각각의 인라인 스크립트의 hash 값을 CSP에 추가합니다. ‘inline-unsafe’ 속성을 제거한 채로 브라우저에서 웹페이지를 로드할 경우 에러 메시지가 뜨는데, 메시지 내부에 해당 인라인 스크립트의 해시값을 얻을 수 있습니다.    빨간 박스 안의 값이 해시값입니다. inline script 마다 고유한 해시값을 갖고 있습니다. CSP의 scriptSrc 옵션에 해당한는 해시값을 추가하면 됩니다. (여러개의 inline script가 있을 경우에는 각각의 해시값을 모두 넣어야합니다.)  // helmet 설정 예 app.use(   helmet.contentSecurityPolicy({     directives: {       defaultSrc: [\"'self'\"],       scriptSrc: [\"'self'\", , \"'sha256-8tCjiEiH4STP6Nn4TLcbKGQVABm858n6iZwulDeFJFA='\"]     },   }) );   hash를 사용할 경우에는 각각의 inline script 마다 해시값을 추가해야하고, inline script가 매번 바뀔 경우 해시값도 매번 바뀌게 된다는 단점이 있습니다. 웹사이트에 inline script가 매우 적고, 항상 동일할 경우에만 사용하는 것이 좋겟습니다.   CSP에 Google Gtag 추가 (Google Tag Manager)  Google Gtag를 손쉽게 관리하기 위해서, 기존 Gtag 코드를 Google Tag Manage로 대체했습니다.     태그 관리자 설정 및 설치하기   태그 관리자 코드에 nonce를 추가하고 몇몇 도메인을 허용해주면, CSP와 함께 구글 태그 관리자를 정상적으로 사용할 수 있습니다.     Using Google Tag Manager with a Content Security Policy   nonce를 추가한 Google Tag Manager 구성 태그  &lt;!-- Google Tag Manager --&gt; &lt;script nonce='{SERVER-GENERATED-NONCE}'&gt;(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src= 'https://www.googletagmanager.com/gtm.js?id='+i+dl;var n=d.querySelector('[nonce]'); n&amp;&amp;j.setAttribute('nonce',n.nonce||n.getAttribute('nonce'));f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-{YOUR-CONTAINER-ID}');&lt;/script&gt; &lt;!-- End Google Tag Manager --&gt;   추가해야할 CSP 옵션 (Google Tag Manager + Google Analytics)  // nonce 생성 app.use((req, res, next) =&gt; {   res.locals.cspNonce = crypto.randomBytes(16).toString(\"hex\");   next(); });  // contentSecurityPolicy 옵션 const cspOptions = {   directives: {     ...helmet.contentSecurityPolicy.getDefaultDirectives(),     \"script-src\": [\"'self'\", \"https://www.googletagmanager.com\", \"https://www.google-analytics.com\",       \"https://ssl.google-analytics.com\", \"https://tagmanager.google.com\", \"*.gstatic.com\", (req, res) =&gt; `'nonce-${res.locals.cspNonce}'`],     \"img-src\": [\"'self'\", \"www.googletagmanager.com\", \"https://www.google-analytics.com\" ,       \"https://*.gstatic.com\", \"https://www.gstatic.com\", \"data:\"],         \"connect-src\": [\"'self'\", \"https://www.google-analytics.com\"]   } }  // contentSecurityPolicy 옵션과 함께 Helmet 기능 전체 활성화 app.use(helmet({   contentSecurityPolicy: cspOptions, }));   Reference          Helmet            Production Best Practices: Security            Content Security Policy (CSP)            CSP: script-src            Content Security Policy            태그 관리자 설정 및 설치하기            Using Google Tag Manager with a Content Security Policy      ","categories": ["Node.js"],
        "tags": ["Node.js","Express","Helmet","CSP"],
        "url": "/nodejs/helmet/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[LoLog.me] 리그오브레전드 전적 상세 조회 기능 추가",
        "excerpt":"  LoLog.me 에서 이제 개별 전적을 조회할 수 있습니다. 유저들에게 가장 친숙한 리그오브레전드 게임 클라이언트의 매치 히스토리 UI를 본따서 제작하였습니다. 그리고 유저들이 궁금해할 만한 정보들을 추가했습니다. 또한 닉네임을 클릭하면 해당 유저를 바로 검색할 수 있습니다.    패치내역           리그오브레전드 클라이언트             LoLog.me         매치 히스토리 데이터는 여러가지의 정보가 결합된 복잡한 데이터입니다. 이로 인해 유저들이 정보를 얻는데 피로하지 않도록 리그오브레전드 클라이언트의 매치 히스토리의 UI를 본땄습니다. 게임이 끝날 때마다 보는 친숙한 화면을 구성함으로써, 유저들의 혼란을 줄이고 편하게 정보를 얻을 수 있도록 했습니다.   추가로 화면을 너무 복잡하지 않게 하는 선에서 유저들이 자주 찾는 정보를 추가했습니다. 메인룬 옆에 보조룬 아이콘을 추가시켰고, 인게임 정보창에서 볼 수 있는 것처럼 와드 아이콘 위에 시야점수를 표시했습니다. 추가로 와드 구매/설치/제거 횟수, 킬 관여율, 분당 CS 는 툴팁으로 추가하였습니다. 또한 유저 닉네임을 클릭하면 해당 유저의 페이지로 바로 이동합니다.   매치 히스토리 UI가 기존의 LoLog.me 사이트의 UI와 자연스럽게 어우러질 수 있도록, 승패에 따라 테마색을 정하고 현재 열려있는 매치 히스토리의 로그 아이콘의 색상을 변경시켰으며, 동일한 색상으로 매치 히스토리 창의 테두리를 추가했습니다.   향후 계획   챔피언별 데미지 그래프 추가  챔피언별 데미지 그래프는 많은 유저들이 가장 궁금해하는 정보이고, 해당 게임의 핵심을 한눈에 확인할 수 있는 매우 중요한 정보입니다. 챔피언별 데미지를 현재 매치 히스토리 정보창에 추가했을 때, 화면이 너무 복잡해졌습니다. 그래서 오른쪽 위에 토글버튼을 만들고 데미지 그래프를 위한 새로운 창을 띄워주는 방식으로 데미지 정보를 제공할 계획입니다. (리그오브레전드 클라이언트에서도 비슷한 방식으로 데미지 그래프를 확인할 수 있으니, 유저에게 더욱 친화적인 방식이라고 생각됩니다)   툴팁 추가  룬, 챔피언, 스펠, 아이템은 아이콘으로만 표시되어 있습니다. 이에 대한 자세한 정보가 궁금한 유저가 있을 것입니다. 따라서 아이템 등에 대한 자세한 정보를 제공하는 툴팁을 만들어야 합니다.   모바일 반응성  이번에 추가된 전적상세 정보는 PC화면에 최적화 되어있습니다. 모바일 사용자들을 위해서는 좀더 압축된 정보창을 제공해야합니다.   최근전적 통계  전적 상세정보를 제공하기 위해, Riot API를 효율적으로 사용하여 Match 데이터를 가져오는 기능을 구현했습니다. 이에 따라 좀더 자세한 정보를 가진 매치 로그를 DB에 저장할 수 있게 되었고, 최근경기에 한해서 더 자세한 통계를 제공할 수 있게 되었습니다. 최근 경기의 승패 정보와 KDA 정보를 한눈에 확인할 수 있게 하고, 이에 대한 통계 그래프를 제공할 예정입니다.   LoLog.me   이전 포스트     [LoLog.me] 한달간 업데이트 내역  ","categories": ["LoL"],
        "tags": ["League of Legend","LoLog.me","Node.js"],
        "url": "/lol/lolog-match/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "MySQL 데이터베이스의 Row 개수와 테이블 크기 구하기",
        "excerpt":"  MySQL의 기본 데이터베이스인, INFORMATION_SCHEMA 의 TABLES 테이블에는 각각의 테이블에 대한 정보가 들어있습니다. SELECT 문으로 필요한 정보만 가져와보도록 하겠습니다.    쿼리문  아래의 SQL 쿼리에서 fancy_data 를 원하는 데이터베이스 이름으로 바꿔주기만 하면 됩니다.  SELECT TABLE_NAME \"Tables\",     ROUND((TABLE_ROWS / 1000), 3) \"Rows (K)\",     AVG_ROW_LENGTH \"Row Size (Byte)\",     ROUND((DATA_LENGTH / 1024 / 1024), 3) \"Data Size (MB)\",     ROUND((INDEX_LENGTH / 1024 / 1024), 3) \"Index Size (MB)\",     ROUND(((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024), 3) \"Total Size (MB)\" FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = \"fancy_data\"  /* 데이터베이스 이름 */ ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC;   결과     쿼리 설명   SELECT (AS는 생략가능)  SELECT 가져올_데이터 AS \"컬럼명\", /*** AS는 ***/     가져올_데이터2 AS \"컬럼명2\",  /* 생략가능 */     ...  ROUND  ROUND((123.45678), 3) /* 소수점 3자리 밑에서 반올림 */   /* -&gt; 123.457 */    /******** 음수도 가능! ********/   FROM, WHERE, ORDER BY  FROM 데이터베이스이름.테이블이름 /* 데이터를 가져올 테이블 */ WHERE 데이터 = 값     /* 조건문 (일치하는 데이터 가져옴) */ ORDER BY 데이터 DESC  /* 데이터 순서로 정렬 (DESC는 내림차순) */   Reference          MySQL 테이블 및 데이타베이스 크기 알아내기            Chapter 26 INFORMATION_SCHEMA Tables            26.38 The INFORMATION_SCHEMA TABLES Table            Select (SQL)            SQL AS Keyword            12.6.2 Mathematical Functions      ","categories": ["MySQL"],
        "tags": ["MySQL","Database"],
        "url": "/mysql/size/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[JavaScript Compressor] 자바스크립트 코드 압축하기",
        "excerpt":"  자바스크립트 코드는 서버에서 통채로 전송되어 브라우저에서 실행되므로 코드 자체의 크기를 줄이면 로딩속도를 향상시킬 수 있습니다.    JavaScript Compressor  자바스크립트 코드를 압축시켜주는 사이트입니다. 자바스크립트 코드를 복사해서 붙여넣고 Compress 버튼을 누르면 주석과 공백을 제거해줍니다.      주의사항   세미콜론 추가  자바스크립트 코드는 세미콜론을 생략해도 제대로 동작합니다. 그러나 압축을 하면서 공백을 제거하게 되면 코드의 의미가 모호해져서 문법 에러가 발생합니다.      VS Code와 같은 에디터를 사용할 경우, 세미콜론이 빠진 부분(문법에러)을 알려줍니다. (ctrl + j)      HTML 공백 체크  자바스크립트의 문자열로 HTML 코드를 작성하는 경우에 태그와 태그 사이에 공백이 사라지면 화면 디자인이 바뀔 수 있습니다.      잘못된 화면    필요한 위치에 공백을 추가하거나, \\n 과 같은 공백문자를 추가하면 해결됩니다.         복구된 화면    HTML 공백 체크 2  태그의 속성(Attribute)를 설정할 때, 따옴표를 사용하지 않고 공백으로만 속성을 설정했을 때 문제가 생깁니다. 따옴표를 추가해줍시다.(ex. width=300 =&gt; width=”300”)           잘못된 화면             복구된 화면        결과     41.5KB 에서 25.9KB 로, 약 62%로 코드 크기가 줄어들었습니다.   Reference     JavaScript Compressor  ","categories": ["JavaScript"],
        "tags": ["JavaScript"],
        "url": "/js/compress/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[LoLog.me] 리그오브레전드 최근 전적, 통계 업데이트",
        "excerpt":"  LoLog.me 에서 이제 최근 전적을 한눈에 볼 수 있고, 승률 통계를 확인할 수 있습니다.    패치내역   기존의 사이트는 검색한 유저의 모든 전적을 아이콘으로 표시했었습니다. 그러나 로그 데이터를 나열하기만한 정보는 별로 유용하지 않았습니다.           이제 한번 검색할 때마다 20개의 기록만을 보여주고, 한눈에 볼 수 있는 더 자세한 정보를 제공합니다. (+ 버튼을 누르면 전적이 20개씩 추가로 로드됩니다)            조회한 게임들의 승률 정보를 추가하여, 유저가 자신의 게임 플레이 스타일을 눈으로 확인할 수 있도록 했습니다.          전적 정보는 다른 전적 검색 사이트들과 비슷하게 구성하였고 최소한의 정보만을 제공하여 유저들이 보기 편하게 만들었습니다.   왼쪽에는 승률그래프를 제공합니다. 다른 사이트들에서는 제공하지 않는 블루팀, 레드팀별 승률 및 시간대별 승률 그래프를 제공합니다.   LoLog.me에서는 날짜별, 챔피언별, 라인별 전적 데이터를 조회할 수 있습니다. 여기에 그에 따른 승률 정보까지 제공하게 되어서 유저들이 좀 더 흥미로워할만한 정보를 제공하게 되었습니다.   향후 계획           챔피언별 데미지 그래프 추가            툴팁 추가            모바일 반응성       이전 포스트     [LoLog.me] 리그오브레전드 전적 상세 조회 기능 추가  ","categories": ["LoL"],
        "tags": ["League of Legend","LoLog.me","Node.js"],
        "url": "/lol/lolog-recent/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[백준 14889] 스타트와 링크 (삼성 기출)",
        "excerpt":"  문제   백준 삼성 SW 역량테스트 기출 문제      14889: 스타트와 링크     풀이   최대 20C10 = 184,756 개의 경우의 수가 존재하므로 완전탐색으로 풀기에 충분하다.   코드 GitHub   /****** BAEKJOON 14889 *****/ /***** SAMSUNG SW TEST *****/ /** Solved Date 2021-04-14 */  #include &lt;iostream&gt; #include &lt;vector&gt;  using namespace std;   int main() { \tint N;  \tcin &gt;&gt; N;      vector&lt;vector&lt;int&gt;&gt; S(N, vector&lt;int&gt;(N, 0));      for (int i = 0; i &lt; N; i ++) {         for (int j = 0; j &lt; N; j++) {             int s;             cin &gt;&gt; s;             S[i][j] = s;         }     } \t \tvector&lt;bool&gt; isA(N, false);      for(int i = 0; i &lt; N / 2; i++) {         isA[i] = true;     }      int min = 1000000;     while(true) {         int sumA = 0;         int sumB = 0;          for(int i = 0; i &lt; N; i++) {             for(int j = 0; j &lt; N; j++) {                 if(isA[i] &amp;&amp; isA[j]) {                     sumA += S[i][j];                 } else if(!isA[i] &amp;&amp; !isA[j]) {                     sumB += S[i][j];                 }             }         }         int del = sumA - sumB;         if(del == 0) {             min = 0;             break;         } else if(del &lt; 0) {             del = 0 - del;         }          if(del &lt; min) {             min = del;         }          // Combination         int cnt = 1;         bool cngd = false;         for(int i = N - 1; i &gt; 0; i--) {             if(!isA[i] &amp;&amp; isA[i - 1]) {                 for(int j = 0; j &lt; cnt; j++) {                     isA[i + j] = true;                     isA[i - 1] = false;                 }                 cngd = true;                 break;             } else if(isA[i]) {                 cnt++;                 isA[i] = false;             }         }         if(!cngd) {             break;         }     }     cout &lt;&lt; min; }   피드백   std::next_permutation   algorithm 라이브러리의 next_permutation 함수를 이용하면 Combination 로직을 쉽게 구현할 수 있다. (배열을 1과 0으로 채운 뒤에 next_permutation 함수를 호출)   vector 대신 배열 이용   메모리 동적 할당이 필요할 때에 배열 대신 vector를 이용하면 편리하다. 그래서 헷갈리지 않게 C++로 알고리즘 문제를 풀때에는 항상 vector를 이용하기로 했다. 그러나 이 문제와 같이 동적할당이 굳이 필요 없는 간단한 문제일 경우에는 배열을 사용하는 것이 가독성과 효율성(코딩 효율)이 좋다. 앞으로는 굳이 vector를 고집하지 않기로 했다.   Reference           14889: 스타트와 링크            std::next_permutation      ","categories": ["Algorithm"],
        "tags": ["Algorithm","Samsung","BOJ"],
        "url": "/boj/14889/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "Visual Studio Code에서 GCC 사용하기",
        "excerpt":"  리눅스 환경에서는 터미널에서 GCC를 쉽게 설치하고 사용할 수 있습니다. 그러나 윈도우에서는 다소 번거로운 작업이 필요합니다. 윈도우 cmd(명령 프롬프트)에서 GCC를 사용할 수 있도록 세팅을 하고 VS code에서 f5키를 눌렀을 때 디버그가 실행되도록 설정해봅시다.     Windows 환경에서 GCC 설치 (MinGW)   1. MinGW-w64 다운로드      MinGW-w64 - for 32 and 64 bit Windows   위의 링크에서 x86_64-posix-seh 파일(.7z)을 다운받습니다.      installer로 설치할 경우 제대로 설치가 되지 않는 문제가 발생하는 경우가 있어서 압축파일을 받는 것을 추천합니다.   2. 압축 해제   다운받은 .7z 파일의 압축을 해제하고 원하는 위치에 저장해줍니다.   저는 C:\\Program Files\\mingw64 이 위치에 저장했습니다.   (.7z 파일의 압축 해제가 되지 않을 경우 반디집을 설치하시면 됩니다)   3. 환경 변수 설정   명령 프롬프트의 어느 위치에서나 GCC를 실행시킬 수 있도록 환경 변수(Path)를 설정해줘야합니다.      시작버튼을 누르고 환경 검색 -&gt; 시스템 환경 변수 편집 에서 다음과 같이 설정해줍니다.      사용자 변수의 Path에 MinGW의 bin 폴더를 추가해주는 작업입니다.   4. 확인   명령 프롬프트를 실행해서 gcc --version을 입력하여 gcc가 제대로 설치 되었는지 확인합니다.   Visual Studio Code 에서 GCC로 컴파일하기   GCC를 설치했다면 VS Code의 터미널(ctrl + j)에서 명령어를 입력하여 gcc를 실행시킬 수 있습니다. 예) g++ file_name.cpp   그러나 몇가지 설정을 하면 f5키를 누르는 것 만으로 컴파일이 되도록 설정할 수 있습니다.   1. C/C++ 익스텐션 설치   먼저 VS Code의 C/C++ 익스텐션을 설치해줍니다.   2. 디버그 설정           컴파일하려는 파일을 열고 f5를 눌러줍니다.            Select environment 창이 뜨면 C++(GDB/LLDB)를 선택해줍니다.            구성으로 g++.exe를 선택해줍니다.       이제 터미널이 자동으로 열리고 디버그 및 실행이 진행됩니다. 설정은 프로젝트마다 한번만 해주면 됩니다.   Reference           Using GCC with MinGW            MinGW-w64 - for 32 and 64 bit Windows            반디집      ","categories": ["Visual Studio Code"],
        "tags": ["Visual Studio Code","GCC"],
        "url": "/vscode/gcc/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[백준 14890] 경사로 (삼성 기출)",
        "excerpt":"  문제   백준 삼성 SW 역량테스트 기출 문제      14890: 경사로    코드 GitHub   /****** BAEKJOON 14890 *****/ /***** SAMSUNG SW TEST *****/ /** Solved Date 2021-04-15 */  #include &lt;iostream&gt;  using namespace std;  int N, L;  int find(int map[][100]) {     int cnt = 0;      for(int i = 0; i &lt; N; i++) {         bool pos = true;         int ramp[100] = {0, };         for(int j = 1; j &lt; N; j++) {             if(map[i][j-1] == map[i][j]) {                 continue;             } else if(abs(map[i][j-1] - map[i][j]) &gt; 1) {                 pos = false;                 break;             } else if(map[i][j-1] &gt; map[i][j]) {                 for(int k = 0; k &lt; L; k++) {                     if(j + k &gt; N - 1) {                         pos = false;                         break;                     } else if(map[i][j] != map[i][j + k]) {                         pos = false;                         break;                     } else {                         ramp[j + k]++;                     }                 }             } else if(map[i][j-1] &lt; map[i][j]) {                 for(int k = 0; k &lt; L; k++) {                     if(j - 1 - k &lt; 0) {                         pos = false;                         break;                     } else if(map[i][j - 1] != map[i][j - 1 - k]) {                         pos = false;                         break;                     } else {                         ramp[j - 1 - k]++;                     }                 }             }         }         for (int k = 0; k &lt; N; k++) {             if (ramp[k] &gt; 1) {                 pos = false;                 break;             }         }         if(pos) {             cnt++;         }     }     return cnt; }  int main() {     int omap[100][100];     int line[100];      cin &gt;&gt; N &gt;&gt; L;      for(int i = 0; i &lt; N; i++) {         for(int j = 0; j &lt; N; j++) {             cin &gt;&gt; omap[i][j];         }     }      int cnt = 0;      cnt += find(omap);      int nmap[100][100];      for(int i = 0; i &lt; N; i++) {         for(int j = 0; j &lt; N; j++) {             nmap[j][i] = omap[i][j];         }     }      cnt += find(nmap);      cout &lt;&lt; cnt; }   Reference      14890: 경사로  ","categories": ["Algorithm"],
        "tags": ["Algorithm","Samsung","BOJ"],
        "url": "/boj/14890/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[백준 14891] 톱니바퀴 (삼성 기출)",
        "excerpt":"  문제   백준 삼성 SW 역량테스트 기출 문제      14891: 톱니바퀴    코드 GitHub   #include &lt;iostream&gt; #include &lt;cmath&gt;  using namespace std;  int Turn(int num, int dir, int gear[][8], int pivot[4], bool left, bool right) {     // Left     if(num &gt; 0 &amp;&amp; left) {         int lpivot = (pivot[num] + 6) % 8;         int rpivot = (pivot[num - 1] + 2) % 8;          if(gear[num][lpivot] != gear[num - 1][rpivot]) {             Turn(num - 1, 0 - dir, gear, pivot, true, false);         }     }      //Right     if(num &lt; 3 &amp;&amp; right) {         int rpivot = (pivot[num] + 2) % 8;         int lpivot = (pivot[num + 1] + 6) % 8;          if(gear[num][rpivot] != gear[num + 1][lpivot]) {             Turn(num + 1, 0 - dir, gear, pivot, false, true);         }     }      // Turn     pivot[num] -= dir;     pivot[num] = (pivot[num] + 8) % 8;      return 1; }  int main() {     int gear[4][8];     int K;      for(int i = 0; i &lt; 4; i++) {         for(int j = 0; j &lt; 8; j++) {             char a;             cin &gt;&gt; a;             gear[i][j] = a - '0';         }     }      cin &gt;&gt; K;      int pivot[4] = {0, };      for(int i = 0; i &lt; K; i++) {         int num, dir;         cin &gt;&gt; num &gt;&gt; dir;          num--;          Turn(num, dir, gear, pivot, true, true);     }      int score = 0;      for(int i = 0; i &lt; 4; i++) {         if(gear[i][pivot[i]] == 1) {             score += pow(2, i);         }     }      cout &lt;&lt; score; }   피드백      제곱     #include &lt;cmath&gt; pow(a,b);           배열 파라미터     int MyFunc(int arr[][10]) {   ... }           Reference      14891: 톱니바퀴  ","categories": ["Algorithm"],
        "tags": ["Algorithm","Samsung","BOJ"],
        "url": "/boj/14891/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[백준 15683] 감시 (삼성 기출)",
        "excerpt":"  문제   백준 삼성 SW 역량테스트 기출 문제      15683: 감시    풀이  각 CCTV의 방향을 돌려가면서 DFS 함수 호출.   코드 GitHub   /****** BAEKJOON 15683 *****/ /***** SAMSUNG SW TEST *****/ /** Solved Date 2021-04-16 */  #include &lt;iostream&gt;  using namespace std;  const int dx[4] = {0, 1, 0, -1}; const int dy[4] = {-1, 0, 1, 0}; const int cctv[5][4] = {     {0, 0, 0, 0},     {0, 2, 0, 0},     {0, 1, 0, 0},     {0, 1, 2, 0},     {0, 1, 2, 3} };  int N, M;  int ans = 64;  int dfs(int map[][8], int x, int y, bool first) {     for(int i = x; i &lt; N; i++) {         for(int j = 0; j &lt; M; j++) {             if(i == x &amp;&amp; j &lt;= y &amp;&amp; !first) continue;              if(0 &lt; map[i][j] &amp;&amp; map[i][j] &lt; 6) {                 for(int k = 0; k &lt; 4; k++) {                     int tmap[8][8];                     // Copy map                     for(int ii = 0; ii &lt; N; ii++) {                         for(int jj = 0; jj &lt; M; jj++) {                             tmap[ii][jj] = map[ii][jj];                         }                     }                     for(int d = 0; d &lt; 4; d++) {                         int dir = (k + cctv[map[i][j] - 1][d]) % 4;                         for(int l = 0; l &lt; 8; l++) {                             if((i + dx[dir] * l) &gt;= N || (i + dx[dir] * l) &lt; 0 || (j + dy[dir] * l) &gt;= M || (j + dy[dir] * l) &lt; 0) {                                 break;                             }                             if(map[i + dx[dir] * l][j + dy[dir] * l] == 0) {                                 tmap[i + dx[dir] * l][j + dy[dir] * l] = 7;                             } else if(map[i + dx[dir] * l][j + dy[dir] * l] == 6) {                                 break;                             }                         }                     }                                          dfs(tmap, i, j, false);                 }                 return 1;             }         }     }      // Count     int cnt = 0;     for(int i = 0; i &lt; N; i++) {         for(int j = 0 ; j &lt; M; j++) {             if(map[i][j] == 0) {                 cnt++;             }         }     }     if (cnt &lt; ans) {         ans = cnt;     }     return 1; }  int main() {     int map[8][8];      // INPUT     cin &gt;&gt; N &gt;&gt; M;     for(int i = 0; i &lt; N; i++) {         for(int j = 0; j &lt; M; j++) {             cin &gt;&gt; map[i][j];         }     }      dfs(map, 0, 0, true);      cout &lt;&lt; ans; }   Reference      15683: 감시  ","categories": ["Algorithm"],
        "tags": ["Algorithm","Samsung","BOJ"],
        "url": "/boj/15683/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[백준 15685] 드래곤 커브 (삼성 기출)",
        "excerpt":"  문제   백준 삼성 SW 역량테스트 기출 문제      15685: 드래곤 커브    코드 GitHub   /****** BAEKJOON 15685 *****/ /***** SAMSUNG SW TEST *****/ /** Solved Date 2021-04-16 */  #include &lt;iostream&gt; #include &lt;vector&gt;  using namespace std;  const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, -1, 0, 1};  int main() {     int N;     cin &gt;&gt; N;      bool map[101][101] = {false, };      for(int i = 0; i &lt; N; i++) {         int x, y, d, g;          cin &gt;&gt; x &gt;&gt; y &gt;&gt; d &gt;&gt; g;          vector&lt;int&gt; path;         path.push_back(d);         map[x][y] = true;          for(int j = 0; j &lt; g; j++) {             int clen = path.size();             for(int k = 0; k &lt; clen; k++) {                 path.push_back((path[clen - 1 - k] + 1) % 4);             }         }          int n = path.size();         for(int j = 0; j &lt; n; j++) {             int dir = path[j];                          x += dx[dir];             y += dy[dir];             map[x][y] = true;         }     }      // Find Rect     int cnt = 0;     for(int i = 0; i &lt; 100; i++) {         for(int j = 0; j &lt; 100; j++) {             if(map[i][j] &amp;&amp; map[i][j+1] &amp;&amp; map[i+1][j] &amp;&amp; map[i+1][j+1]) {                 cnt++;             }         }     }     cout &lt;&lt; cnt; }   피드백      vector     #include &lt;vector&gt; vector&lt;int&gt; v; v.push_back(1); v.size();                좌표 평면의 방향 체크하기       문제 잘 읽기     드래곤 커브로 둘러싸인 사각형 X 모든 꼭지점이 드래곤 커브에 포함된 사각형 O           귀찮아도 적으면서(그리면서) 할 것   Reference      15685: 드래곤 커브  ","categories": ["Algorithm"],
        "tags": ["Algorithm","Samsung","BOJ"],
        "url": "/boj/15685/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[백준 15686] 치킨 배달 (삼성 기출)",
        "excerpt":"  문제   백준 삼성 SW 역량테스트 기출 문제      15686: 치킨 배달    코드 GitHub   /****** BAEKJOON 15686 *****/ /***** SAMSUNG SW TEST *****/ /** Solved Date 2021-04-18 */  #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt;  using namespace std;  int main() {     int N, M;     cin &gt;&gt; N &gt;&gt; M;      int map[50][50];     int hnum = 0;     int cnum = 0;     vector&lt;vector&lt;int&gt;&gt; home;     vector&lt;vector&lt;int&gt;&gt; ckn;      for(int i = 0; i &lt; N; i++) {         for(int j = 0; j &lt; N; j++) {             cin &gt;&gt; map[i][j];             if(map[i][j] == 1) {                 hnum++;                 home.push_back({i, j});             } else if(map[i][j] == 2) {                 cnum++;                 ckn.push_back({i, j});             }         }     }      int dis[100][13];      for(int i = 0; i &lt; hnum; i++) {         for(int j = 0; j &lt; cnum; j++) {             dis[i][j] = abs(home[i][0] - ckn[j][0]) + abs(home[i][1] - ckn[j][1]);         }     }      int com[13] = {0, };      for(int i = 0; i &lt; M; i++) {         com[i] = 1;     }      int minC = 10000;      do {         int cknL = 0;         for(int i = 0; i &lt; hnum; i++) {             int min = 100;             for(int j = 0; j &lt; cnum; j++) {                 if(com[j] == 0) continue;                  if(min &gt; dis[i][j]) min = dis[i][j];             }             cknL += min;         }          if(minC &gt; cknL) minC = cknL;     } while(prev_permutation(com, com + cnum));      cout &lt;&lt; minC; }   피드백      permutation     #include &lt;algorithm&gt; int arr[4] = {1, 1, 0, 0}; do {   ... } while(prev_permutation(arr, arr + 4));          prev_permutation: 내림차순  next_permutation: 오름차순       Reference           15686: 치킨 배달            std::next_permutation      ","categories": ["Algorithm"],
        "tags": ["Algorithm","Samsung","BOJ"],
        "url": "/boj/15686/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[백준 5373] 큐빙 (삼성 기출)",
        "excerpt":"  문제   백준 삼성 SW 역량테스트 기출 문제      5373: 큐빙    코드 GitHub   /****** BAEKJOON 5373  *****/ /***** SAMSUNG SW TEST *****/ /** Solved Date 2021-04-18 */  #include &lt;iostream&gt; #include &lt;vector&gt;  using namespace std;  const char PORDER[6] = {'U', 'F', 'L', 'D', 'B', 'R'}; const int ROTATED[9] = {6, 3, 0, 7, 4, 1, 8, 5, 2}; const int SORDER[6][4][4] = {     { {4, 6, 7, 8}, {2, 8, 5, 2}, {1, 2, 1, 0}, {5, 0, 3, 6} },     { {0, 6, 7 ,8}, {2, 6, 7, 8}, {3, 6, 7, 8}, {5, 6, 7, 8} },     { {4, 0, 3, 6}, {3, 8, 5, 2}, {1, 0, 3, 6}, {0, 0, 3, 6} },     { {4, 2, 1, 0}, {5, 8, 5, 2}, {1, 6, 7, 8}, {2, 0, 3, 6} },     { {3, 2, 1, 0}, {2, 2, 1, 0}, {0, 2, 1, 0}, {5, 2, 1, 0} },     { {4, 8, 5, 2}, {0, 8, 5, 2}, {1, 8, 5, 2}, {3, 0, 3, 6} } };  int RotateTop(char plane[9]) {     char org[9];     for(int i = 0; i &lt; 9; i++) {         org[i] = plane[i];     }     for(int i = 0; i &lt; 9; i++) {         plane[i] = org[ROTATED[i]];     }     return 1; } int RotateSide(char cube[][9], int pivot) {     char tmp[3];     for(int i = 0; i &lt; 3; i++) {         tmp[i] = cube[SORDER[pivot][0][0]][SORDER[pivot][0][i + 1]];     }     for(int i = 1; i &lt; 4; i++) {         for(int j = 0; j &lt; 3; j++) {             cube[SORDER[pivot][i - 1][0]][SORDER[pivot][i - 1][j + 1]] = cube[SORDER[pivot][i][0]][SORDER[pivot][i][j + 1]];         }     }     for(int j = 0; j &lt; 3; j++) {         cube[SORDER[pivot][3][0]][SORDER[pivot][3][j + 1]] = tmp[j];     }     return 1; }  int main() {     int T;     cin &gt;&gt; T;     for(int t = 0; t &lt; T; t++) {         // U F L D B R         char cube[6][9] = {             {'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w'},             {'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r'},             {'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g'},             {'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y', 'y'},             {'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o', 'o'},             {'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'}         };          int N;         cin &gt;&gt; N;          for(int n = 0; n &lt; N; n++) {             char a, b;             cin &gt;&gt; a &gt;&gt; b;              int pln;             bool clk;              for(int i = 0; i &lt; 6; i++) {                 if(PORDER[i] == a) {                     pln = i;                     break;                 }             }              clk = b == '+';              RotateTop(cube[pln]);             RotateSide(cube, pln);              if(!clk) {                 RotateTop(cube[pln]);                 RotateSide(cube, pln);                 RotateTop(cube[pln]);                 RotateSide(cube, pln);             }         }          for(int i = 0; i &lt; 9; i++) {             cout &lt;&lt; cube[0][i];             if(i % 3 == 2) {                 cout &lt;&lt; '\\n';             }         }     } }   Reference      5373: 큐빙  ","categories": ["Algorithm"],
        "tags": ["Algorithm","Samsung","BOJ"],
        "url": "/boj/5373/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[백준 16234] 인구 이동 (삼성 기출)",
        "excerpt":"  문제   백준 삼성 SW 역량테스트 기출 문제      16234: 인구 이동    코드 GitHub   #include &lt;iostream&gt; #include &lt;cmath&gt;  using namespace std;  int N, L, R; int A[50][50]; int B[50][50];  int Check(int r, int c, int b) {     if(B[r][c] != 0) return 0;      int sum = A[r][c];     B[r][c] = b;      if(r &lt; N - 1) {         int dif = abs(A[r][c] - A[r + 1][c]);         if(dif &gt;= L &amp;&amp; dif &lt;= R) {             sum += Check(r + 1, c, b);         }     }     if(r &gt; 0) {         int dif = abs(A[r][c] - A[r - 1][c]);         if(dif &gt;= L &amp;&amp; dif &lt;= R) {             sum += Check(r - 1, c, b);         }     }      if(c &lt; N - 1) {         int dif = abs(A[r][c] - A[r][c + 1]);         if(dif &gt;= L &amp;&amp; dif &lt;= R) {             sum += Check(r, c + 1, b);         }     }     if(c &gt; 0) {         int dif = abs(A[r][c] - A[r][c - 1]);         if(dif &gt;= L &amp;&amp; dif &lt;= R) {             sum += Check(r, c - 1, b);         }     }      return sum; }  int main() {     cin &gt;&gt; N &gt;&gt; L &gt;&gt; R;      for(int i = 0; i &lt; N; i++)         for(int j = 0; j &lt; N; j++)             cin &gt;&gt; A[i][j];      int cnt = 0;     while(true) {         for(int i = 0; i &lt; N; i++) {             for(int j = 0; j &lt; N; j++) {                 B[i][j] = 0;             }         }          int b = 1;         for(int i = 0; i &lt; N; i++) {             for(int j = 0; j &lt; N; j++) {                 int sum = Check(i, j, b);                 if(B[i][j] == b) {                     if(A[i][j] != sum) {                         int bnum = 0;                         for(int k = 0; k &lt; N; k++) {                             for(int l = 0; l &lt; N; l++) {                                 if(B[k][l] == b) {                                     bnum++;                                 }                             }                         }                         int np = sum / bnum;                         for(int k = 0; k &lt; N; k++) {                             for(int l = 0; l &lt; N; l++) {                                 if(B[k][l] == b) {                                     A[k][l] = np;                                 }                             }                         }                     }                     b++;                 }             }         }          if(b == N * N + 1) {             cout &lt;&lt; cnt;             break;         } else {             cnt++;         }     } }   Reference      16234: 인구 이동  ","categories": ["Algorithm"],
        "tags": ["Algorithm","Samsung","BOJ"],
        "url": "/boj/16234/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[프로그래머스] 합승 택시 요금 (카카오 기출)",
        "excerpt":"  문제   프로그래머스 2021 KAKAO BLIND RECRUITMENT 기출문제      합승 택시 요금    풀이   A, B, S 세개의 지점에서 모든 지점으로의 최단거리를 다익스트라(Dijkstra) 알고리즘을 이용하여 구한다.   세 지점으로부터 최단거리의 합이 가장 작은 하나의 지점을 찾아 합승 종료 지점으로 한다.   코드 GitHub   #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt;  using namespace std;  const int INF = 10000000; int map[200][200];  void Dijk(int start, int n, vector&lt;int&gt;&amp; dis) {     dis[start] = 0;     priority_queue&lt;pair&lt;int, int&gt;&gt; pq;     pq.push(make_pair(start, 0));          while(!pq.empty()) {         int next = pq.top().first;         int cdis = - pq.top().second;         pq.pop();                  if(cdis &gt; dis[next]) continue;                  for(int i = 0; i &lt; n; i++) {             int ndis = cdis + map[i][next];             if(dis[i] &gt; ndis) {                 dis[i] = ndis;                 pq.push(make_pair(i, - ndis));             }         }     }     return; }  int solution(int n, int s, int a, int b, vector&lt;vector&lt;int&gt;&gt; fares) {     int answer = INF;          for(int i = 0; i &lt; n; i++) {         for(int j = 0; j &lt; n; j++) {             map[i][j] = INF;             if(i == j) {                 map[i][j] = 0;             }         }     }          for(auto fare : fares) {         int r = fare[0] - 1;         int c = fare[1] - 1;         int dis = fare[2];         map[r][c] = dis;         map[c][r] = dis;     }          vector&lt;vector&lt;int&gt;&gt; dis(3, vector&lt;int&gt;(n, INF));     Dijk(s - 1, n, dis[0]);     Dijk(a - 1, n, dis[1]);     Dijk(b - 1, n, dis[2]);          for(int i = 0; i &lt; n; i++) {         int sum = 0;         for(auto elem : dis) {             sum += elem[i];         }         if(sum &lt; answer) answer = sum;     }          return answer; }   Reference      합승 택시 요금  ","categories": ["Algorithm"],
        "tags": ["Algorithm","Kakao","Programmers"],
        "url": "/kakao/taxi/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[프로그래머스] 광고 삽입 (카카오 기출)",
        "excerpt":"  문제   프로그래머스 2021 KAKAO BLIND RECRUITMENT 기출문제      광고 삽입    풀이   광고의 시작지점, 끝 지점을 입력받아 정렬시키고, 슬라이딩 윈도우 기법을 이용하여 답을 구합니다.   코드 GitHub   #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt;  using namespace std;  int ParseTime(string time) {     int sum = 0;     // Hour     int h = stoi(time.substr(0, 2));     sum += h * 3600;          // Minute     int m = stoi(time.substr(3, 2));     sum += m * 60;          // Sec     int s = stoi(time.substr(6, 2));     sum += s;          return sum; }  string Encode(int time) {     int h = time / 3600;     int m = time / 60 % 60;     int s = time % 60;          string str = \"\";     str += (h / 10) + '0';     str += (h % 10) + '0';     str += ':';     str += (m / 10) + '0';     str += (m % 10) + '0';     str += ':';     str += (s / 10) + '0';     str += (s % 10) + '0';          return str; }  string solution(string play_time, string adv_time, vector&lt;string&gt; logs) {     string answer = \"\";     int ptime = ParseTime(play_time);     int atime = ParseTime(adv_time);          vector&lt;int&gt; stimes;     vector&lt;int&gt; etimes;          for(string log : logs) {         stimes.push_back(ParseTime(log.substr(0, 8)));         etimes.push_back(ParseTime(log.substr(9, 8)));     }          sort(stimes.begin(), stimes.end());     sort(etimes.begin(), etimes.end());      long max = 0;     int ans = 0;          int scnt = 0;     int ecnt = 0;     int stk = 0;     for(int i = 0; i &lt; atime; i++) {         while(scnt &lt; stimes.size() &amp;&amp; stimes[scnt] &lt;= i) {             stk++;             scnt++;         }         while(ecnt &lt; etimes.size() &amp;&amp; etimes[ecnt] &lt;= i) {             stk--;             ecnt++;         }         max += stk;     }          long maxx = max;          int sscnt = 0;     int eecnt = 0;     for(int i = atime; i &lt; ptime; i++) {         while(sscnt &lt; stimes.size() &amp;&amp; stimes[sscnt] &lt;= i - atime) {             stk--;             sscnt++;         }         while(eecnt &lt; etimes.size() &amp;&amp; etimes[eecnt] &lt;= i - atime) {             stk++;             eecnt++;         }                  while(scnt &lt; stimes.size() &amp;&amp; stimes[scnt] &lt;= i) {             stk++;             scnt++;         }         while(ecnt &lt; etimes.size() &amp;&amp; etimes[ecnt] &lt;= i) {             stk--;             ecnt++;         }         max += stk;         if(max &gt; maxx) {             maxx = max;             ans = i - atime + 1;         }     }          answer = Encode(ans);          return answer; }   Reference      광고 삽입  ","categories": ["Algorithm"],
        "tags": ["Algorithm","Kakao","Programmers"],
        "url": "/kakao/ad/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[LoLog.me] 챔피언에게 가한 피해량 그래프, 모바일 반응성 향상 업데이트",
        "excerpt":"  LoLog.me 에서 이제 챔피언에게 가한 피해량 그래프를 확인할 수 있습니다.   모바일 반응성이 향상되었습니다.    챔피언에게 가한 피해량(딜량) 그래프     그래프 토글 버튼을 클릭하면 챔피언별 딜량을 확인할 수 있습니다. 토글 버튼과 그래프는 유저에게 친숙한 리그오브레전드 클라이언트 UI와 비슷하게 설정하였습니다.   모바일 반응성 향상       최근 전적 리스트와 상세 전적 검색의 화면 구성이 모바일에서 깔끔하지 않게 보여졌습니다. 모바일에서는 몇몇의 데이터를 숨기고 모바일 화면에 맞게 사이즈를 줄여 반응성을 향상시켰습니다.   이전 포스트     [LoLog.me] 리그오브레전드 최근 전적, 통계 업데이트  ","categories": ["LoL"],
        "tags": ["League of Legend","LoLog.me","Node.js"],
        "url": "/lol/lolog-recent2/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[PAT] GitHub Personal Access Token(PAT) 발급 & 캐싱",
        "excerpt":"  AWS EC2 Linux 서버에서 GitHub id, password를 사용하여 git pull을 할 때마다 [GitHub] Deprecation Notice라는 제목의 메일이 왔습니다. id와 password를 통해 깃허브에 접근하는 것이 보안상의 이유로 곧 사용할 수 없게 될 것이라는 내용의 메일이었습니다. 그래서 서버에서 사용할 전용 Personal Access Token을 발급하고 이를 매번 입력할 필요가 없도록 캐싱해주었습니다.    GitHub PAT 발급     Creating a personal access token   메뉴 -&gt; Settings -&gt; Developer settings -&gt; Personal access token 의 경로에서 Generate new token 버튼을 눌러 토큰을 생성합니다.   토큰은 생성 당시에 한번만 노출되고 더이상 확인할 수 없으니 잘 저장해두셔야 합니다. 토큰을 잃어버릴 경우에는 찾을 수 없고, 재발급 받아야합니다.   캐싱     Caching your GitHub credentials in Git   리눅스 캐싱 명령어  $ git config --global credential.helper cache # Set git to use the credential memory cache  기본적으로 15분 동안 캐싱이 되고, 캐싱 시간을 변경하기 위해서는 아래의 명령어를 사용합니다.  $ git config --global credential.helper 'cache --timeout=3600' # Set the cache to timeout after 1 hour (setting is in seconds)   Reference          Creating a personal access token            Caching your GitHub credentials in Git      ","categories": ["GitHub"],
        "tags": ["GitHub","PAT","AWS","EC2","Linux"],
        "url": "/github/pat-cache/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[Blender] 로우폴리 나무 (Low-poly Tree)",
        "excerpt":"  블랜더로 모델링하고 렌더링한 로우폴리 나무입니다. 튜토리얼을 따라가니 첫작품 치고 꽤나 만족스러운 결과가 나왔습니다.    튜토리얼   유튜버 까망고니님의 튜토리얼 영상을 참고하였습니다.        그럴듯한 로우폴리 나무가 만들어졌습니다.   응용      튜토리얼을 응용하여 좀 더 크고 풍성한 로우폴리 나무를 만들어 보았습니다.         색상을 변경하여 벚꽃과 단풍나무를 만들어 보았습니다.   Reference     블렌더 강좌 | 로우폴리 나무 이 영상 하나로 완전정복 | Blender 2.8x  ","categories": ["Blender"],
        "tags": ["Blender","Low-poly","3D"],
        "url": "/blender/lowpoly-tree/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[Blender] 로우폴리 치킨 (Low-poly Chicken)",
        "excerpt":"  블랜더로 모델링하고 렌더링한 로우폴리 치킨입니다. 이번에도 유튜버 까망고니님의 튜토리얼 영상을 참고하였습니다.    튜토리얼   유튜버 까망고니님의 튜토리얼 영상입니다.        양념치킨      완성하기까지 3시간 이상 걸렸습니다 ㅠ      후작업은 실패…   후라이드      뭔가 어색한 후라이드 치킨   치킨 낙하        튜토리얼 진행중 치킨 낙하 장면   Reference     블렌더 강좌 | 로우폴리 치킨 이 영상 하나로 완전정복 | Blender 2.8x  ","categories": ["Blender"],
        "tags": ["Blender","Low-poly","3D"],
        "url": "/blender/lowpoly-chicken/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 3316. 동아리실 관리하기 (C++, 라이브러리 X)",
        "excerpt":"  비트연산자 기본문제   풀이   동아리원이 총 4명이므로 4비트로 모든 경우의 수를 표현할 수 있음.   0b0000부터 0b1111까지(0 부터 15까지) 1씩 더해가면 경우의 수를 체크하며 카운트.     코드 GitHub   #include&lt;iostream&gt;  using namespace std;  int main(int argc, char** argv) { \tint test_case; \tint T; \tfreopen(\"input.txt\", \"r\", stdin); \tcin&gt;&gt;T; \tfor(test_case = 1; test_case &lt;= T; ++test_case) \t{         char chiefs[10000];         int pivot = 0;         int *counts = new int[16];          cin &gt;&gt; chiefs;          for(int i = 0; i &lt; 16; i++) counts[i] = 0;          counts[1]++;          while(chiefs[pivot]) {             int *newCnts = new int[16];             for(int i = 0; i &lt; 16; i++) newCnts[i] = 0;              int chief = chiefs[pivot] - 'A';              for(int i = 0; i &lt; 16; i++) {                 if(!(i &amp; 1 &lt;&lt; chief)) continue;                  long long cnt = 0;                 for(int j = 0; j &lt; 16; j++) {                     if(!(j &amp; i)) continue;                      cnt += counts[j];                      if(cnt &gt; 1000000007) cnt %= 1000000007;                 }                                  newCnts[i] = cnt;             }              delete counts;             counts = newCnts;                          pivot++;         }          int sum = 0;         for(int i = 0; i &lt; 16; i++) {             sum += counts[i];             if(sum &gt; 1000000007) sum %= 1000000007;         }          delete counts;          cout &lt;&lt; '#' &lt;&lt; test_case &lt;&lt; ' ' &lt;&lt; sum &lt;&lt; endl; \t} \treturn 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++"],
        "url": "/swea/3316/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 1288. 새로운 불면증 치료법 (C++, 라이브러리 X)",
        "excerpt":"  비트연산자 기본문제   풀이   int형 변수 check를 선언하여 숫자 하나당 1bit씩 할당.   10개의 bit이 모두 1이 될 때까지 체크.     코드 GitHub   #include&lt;iostream&gt; using namespace std;  int main() { \tint test_case; \tint T; \tfreopen(\"input.txt\", \"r\", stdin); \tcin&gt;&gt;T; \tfor(test_case = 1; test_case &lt;= T; ++test_case) \t{         int N;         int check = 0;         int CN = 0;          cin &gt;&gt; N;          while(true) {             CN += N;              int tmp = CN;              while(tmp &gt; 0) {                 check |= 1 &lt;&lt; (tmp % 10);                 tmp /= 10;             }              if(check == (1 &lt;&lt; 10) - 1) break;         }          cout &lt;&lt; '#' &lt;&lt; test_case &lt;&lt; ' ' &lt;&lt; CN &lt;&lt; endl; \t} \treturn 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++"],
        "url": "/swea/1288/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 6960. 자영이의 퍼스트 솔브 (C++, 라이브러리 X)",
        "excerpt":"  DP 실전문제   풀이   F에 대하여 오름차순으로 정렬.   dp[i][j] 는 i번째 문제까지 중에서 j개의 문제를 풀었을 때 걸리는 최소 시간.   dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + S[i])   dp[i][j] &gt; F[i] 일 경우, dp[i][j] = INF   dp[N][N] 부터 dp[N][0] 까지 탐색중 최초로 INF가 아닐때 j 값이 정답.     코드 GitHub   #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std;  #define MAXN 1000 #define MAXF 1000000 #define INF 2000001  int N; int ss[MAXN]; int fs[MAXN];  int idx[MAXN];  int dp[MAXN + 1][MAXN + 1];  void QuickSort(int l, int r) {     if(l &gt;= r) return;     int m = (l + r) / 2;     int pivotL = l;     int pivotR = r;     while(true) {         while(pivotL &lt; m &amp;&amp; fs[idx[pivotL]] &lt;= fs[idx[m]]) pivotL++;         while(pivotR &gt; m &amp;&amp; fs[idx[pivotR]] &gt;= fs[idx[m]]) pivotR--;         if(pivotL == pivotR) break;         int tmp = idx[pivotL];         idx[pivotL] = idx[pivotR];         idx[pivotR] = tmp;         if(pivotL == m) m = pivotR;         else if(pivotR == m) m = pivotL;     }          QuickSort(l, m - 1);     QuickSort(m + 1, r);     return; }  int FindD(int _idx, int solved) {     if(dp[_idx][solved] != -1) return dp[_idx][solved];     if(solved == 0) {         dp[_idx][solved] = 0;         return 0;     }     if(_idx == 0) {         dp[_idx][solved] = INF;         return INF;     }     int min = FindD(_idx - 1, solved);     int b = FindD(_idx - 1, solved - 1) + ss[idx[_idx - 1]];     if(min &gt; b) min = b;     if(min &gt; fs[idx[_idx - 1]]) min = INF;     dp[_idx][solved] = min;     return min; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     //freopen(\"s_input.txt\", \"r\", stdin);      int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;= T; tc++) {         N;         cin &gt;&gt; N;         for(int n = 0; n &lt; N; n++) {             cin &gt;&gt; ss[n] &gt;&gt; fs[n];             idx[n] = n;         }         QuickSort(0, N - 1);          for(int i = 0; i &lt;= N; i++)             for(int j = 0; j &lt;= N; j++) dp[i][j] = -1;         for(int i = 0; i &lt;= N; i++) FindD(N, i);         int cnt = N;         while(dp[N][cnt] == INF) cnt--;          cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; \"\\n\";     } }   ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","DP"],
        "url": "/swea/6960/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 8935. 스팟마트 (C++, 라이브러리 X)",
        "excerpt":"  DP 실전문제   풀이   M개의 봉지 B를 오름차순으로 정렬.   dp[n][l][r][take] 설정. (현재 상태에서 최대 과자 개수)   n은 N개의 봉지 중에서 n번째 봉지까지 확인한 상태.   l은 M개의 봉지 중에서 l개를 가져간 상태. (항상 큰 봉지 먼저 가져감)   r은 M개의 봉지 중에서 r개를 버린 상태. (항상 작은 봉지 먼저 버림)   take가 0이면 현재 봉지를 버리고, 1이면 가져감.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXN 3000 #define MAXM 100  int N, M; int A[MAXN], B[MAXM]; int dp[MAXN + 1][MAXM + 1][MAXM + 1][2];  int Find(int idx, int l, int r, int take) {     if(dp[idx][l][r][take] != -1) return dp[idx][l][r][take];     if(idx == 0 &amp;&amp; l == 0) return dp[idx][l][r][take] = 0;     if(l + r &gt; M) return dp[idx][l][r][take] = 0;      int val;     if(take == 1) {         int f1 = 0, f2 = 0;         if(idx &gt; 0) f1 = Find(idx - 1, l, r, 0) + A[idx - 1];         if(l &gt; 0) f2 = Find(idx, l - 1, r, 0) + B[M - l];         val = (f1 &gt; f2) ? f1 : f2;     } else {         int f1 = 0, f2 = 0, f3 = 0, f4 = 0;         if(idx &gt; 0) {             f1 = Find(idx - 1, l, r, 0);             f2 = Find(idx - 1, l, r, 1);         }         if(r &gt; 0) {             f3 = Find(idx, l, r - 1, 0);             f4 = Find(idx, l, r - 1, 1);         }         val = (f1 &gt; f2) ? f1 : f2;         if(f3 &gt; val) val = f3;         if(f4 &gt; val) val = f4;     }     return dp[idx][l][r][take] = val; }  void QuickSort(int l, int r) {     if(l &gt;= r) return;     int pivotL = l;     int pivotR = r;     int m = (l + r) / 2;     while(true) {         while(pivotL &lt; m &amp;&amp; B[pivotL] &lt;= B[m]) pivotL++;         while(pivotR &gt; m &amp;&amp; B[pivotR] &gt;= B[m]) pivotR--;         if(pivotL == pivotR) break;         int tmp = B[pivotL];         B[pivotL] = B[pivotR];         B[pivotR] = tmp;         if(m == pivotL) m = pivotR;         else if(m == pivotR) m = pivotL;     }     QuickSort(l, m - 1);     QuickSort(m + 1, r);     return; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     // freopen(\"input.txt\", \"r\", stdin);      int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;= T; tc++) {         cin &gt;&gt; N;         for(int n = 0; n &lt; N; n++) cin &gt;&gt; A[n];         cin &gt;&gt; M;         for(int m = 0; m &lt; M; m++) cin &gt;&gt; B[m];         for(int n = 0; n &lt;= N; n++) for(int m = 0; m &lt;= M; m++)             for(int m2 = 0; m2 &lt;= M; m2++) {                 dp[n][m][m2][0] = -1;                 dp[n][m][m2][1] = -1;             }         QuickSort(0, M - 1);          int max = 0;         for(int l = 0; l &lt;= M; l++) {             int r = M - l;             if(Find(N, l, r, 0) &gt; max) max = dp[N][l][r][0];             if(Find(N, l, r, 1) &gt; max) max = dp[N][l][r][1];         }         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; max &lt;&lt; '\\n';     } }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","DP"],
        "url": "/swea/8935/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 1231. 중위순회 (C++, 라이브러리 X)",
        "excerpt":"  Tree 기본문제   풀이   자식 유무에 따라서 input 개수가 달라짐.   cin.get() 함수로 줄바꿈 문자인지 체크.   (cin.get()은 한문자씩 입력받고, 공백 문자나 개행 문자를 생략하지 않음.)   Inorder 함수를 이용하여 in-order 형식으로 Tree 순회.   (왼쪽 자식 트리 순회 후, 자기 자신 출력, 마지막으로 오른쪽 자식 트리 순회)     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXN 100  int N;  struct Node {     char alpha;     int children[2]; } nodes[MAXN];  char text[MAXN]; int textCnt;  void Inorder(int idx) {     if(nodes[idx].children[0] != -1) Inorder(nodes[idx].children[0]);     text[textCnt++] = nodes[idx].alpha;     if(nodes[idx].children[1] != -1) Inorder(nodes[idx].children[1]);     return; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     freopen(\"input.txt\", \"r\", stdin);     for(int tc = 1; tc &lt;= 10; tc++) {         cin &gt;&gt; N;         for(int n = 0; n &lt; N; n++) {             int idx;             cin &gt;&gt; idx;             idx--;             char alpha;             cin &gt;&gt; alpha;             int children[2] = {0, };             if(cin.get() != '\\n') {                 cin &gt;&gt; children[0];                 if(cin.get() != '\\n') cin &gt;&gt; children[1];             }             children[0]--;             children[1]--;             nodes[idx].alpha = alpha;             nodes[idx].children[0] = children[0];             nodes[idx].children[1] = children[1];         }         textCnt = 0;         Inorder(0);         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ';         for(int i = 0; i &lt; textCnt; i++) cout &lt;&lt; text[i];         cout &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Tree"],
        "url": "/swea/1231/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 1232. 사칙연산 (C++, 라이브러리 X)",
        "excerpt":"  Tree 기본문제   풀이   기호, 숫자, 자식노드에 따라서 입력 형태가 바뀜.   따라서 문자열로 받아서 파싱.   root 부터 재귀적으로 자식 노드 탐색 및 계산.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXN 1000  int N;  struct Node {     bool isNum;     int num;     int children[2]; } nodes[MAXN];  double Calc(int idx) {     if(nodes[idx].isNum) return (double) nodes[idx].num;     double c1 = Calc(nodes[idx].children[0]);     double c2 = Calc(nodes[idx].children[1]);     switch(nodes[idx].num) {         case '+': return c1 + c2;         case '-': return c1 - c2;         case '*': return c1 * c2;         case '/': return c1 / c2;         default : return -1;     }     return -1; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     freopen(\"input.txt\", \"r\", stdin);      for(int tc = 1; tc &lt;=10; tc++) {         cin &gt;&gt; N;         for(int n = 0; n &lt; N; n++) {             int idx;             cin &gt;&gt; idx;             idx--;             char str[10];             cin &gt;&gt; str;             if(str[0] &gt;= '0' &amp;&amp; str[0] &lt;= '9') {                 nodes[idx].isNum = true;                 int num = 0;                 for(int i = 0; str[i]; i++) {                     num *= 10;                     num += str[i] - '0';                 }                 nodes[idx].num = num;             } else {                 nodes[idx].isNum = false;                 int num = str[0];                 int c1, c2;                 cin &gt;&gt; c1 &gt;&gt; c2;                 c1--;c2--;                 nodes[idx].num = num;                 nodes[idx].children[0] = c1;                 nodes[idx].children[1] = c2;             }         }         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; Calc(0) &lt;&lt; '\\n';     }          return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Tree"],
        "url": "/swea/1232/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 1233. 사칙연산 유효성 검사 (C++, 라이브러리 X)",
        "excerpt":"  Tree 기본문제   풀이   Tree 기본문제이지만 Tree를 만들 필요가 없음.   입력을 받는 단계에서 유효성 검사 가능.   노드가 연산자일 경우 두개의 자식 노드가 존재해야하고, 수일 경우 자식 노드가 없어야함.   노드의 인덱스 * 2 가 N 보다 작을 경우 두개의 자식 노드가 존재하고, 클 경우 자식 노드가 없음.   인덱스 * 2 가 N과 같을 경우(N이 짝수일 경우) 는 자식 노드가 하나밖에 없는 노드가 존재하므로 연산 불가능.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  char str[20];  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     freopen(\"input.txt\", \"r\", stdin);     for(int tc = 1; tc &lt;= 10; tc++) {         int N;         cin &gt;&gt; N;         bool pos = true;         for(int n = 0; n &lt; N; n++) {             if(!pos) {                 cin.getline(str, 20);                 continue;             }             int idx;             cin &gt;&gt; idx;             if(idx * 2 &lt; N) {                 char a;                 cin &gt;&gt; a;                 if(a &gt;= '0' &amp;&amp; a &lt;= '9') {                     pos = false;                     cin.getline(str, 20);                     continue;                 }                 int b, c;                 cin &gt;&gt; b &gt;&gt; c;             } else if(idx * 2 == N) {                 pos = false;                 cin.getline(str, 20);                 continue;             } else {                 char a;                 cin &gt;&gt; a;                 if(a &lt; '0' || a &gt; '9') {                     pos = false;                     cin.getline(str, 20);                     continue;                 }             }         }         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; pos &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Tree"],
        "url": "/swea/1233/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 1970. 쉬운 거스름돈 (C++, 라이브러리 X)",
        "excerpt":"  Greedy 기본문제   풀이   단위가 큰 수부터 뺄 수 없을 때까지 빼면서 카운트.     코드 GitHub   #include&lt;iostream&gt;  using namespace std;  #define COIN_NUM 8  const int COIN[COIN_NUM] {50000, 10000, 5000, 1000, 500, 100, 50, 10};  int main(int argc, char** argv) { \tint test_case; \tint T; \tfreopen(\"input.txt\", \"r\", stdin); \tcin&gt;&gt;T; \tfor(test_case = 1; test_case &lt;= T; ++test_case) \t{         int N;         cin &gt;&gt; N;          cout &lt;&lt; \"#\" &lt;&lt; test_case &lt;&lt; endl;          for(int i = 0; i &lt; COIN_NUM; i++) {             int coin = COIN[i];             int cnt = 0;              while(N &gt;= coin) {                 N -= coin;                 cnt++;             }              cout &lt;&lt; cnt &lt;&lt; ' ';         }          cout &lt;&lt; endl; \t} \treturn 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Greedy"],
        "url": "/swea/1970/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 2930. 힙 (C++, 라이브러리 X)",
        "excerpt":"  Heap 기본문제   풀이   배열로 힙 (Add, Pop) 구현하기.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXN 100000  int heap[MAXN]; int heapCnt;  void Add(int val) {     int pivot = heapCnt;     heap[heapCnt++] = val;     while(pivot &gt; 0) {         int ppivot = pivot;         pivot--;         pivot = pivot &gt;&gt; 1;         if(heap[pivot] &lt; val) {             heap[ppivot] = heap[pivot];             heap[pivot] = val;         } else return;     }     return; } int Pop() {     if(heapCnt == 0) return -1;     int val = heap[0];     heapCnt--;     heap[0] = heap[heapCnt];     int pivot = 0;     while(true) {         int ppivot = pivot;         pivot = pivot &lt;&lt; 1;         pivot++;         if(pivot &gt;= heapCnt) {             break;         } else if(pivot + 1 == heapCnt) {             if(heap[ppivot] &gt; heap[pivot]) break;             int tmp = heap[ppivot];             heap[ppivot] = heap[pivot];             heap[pivot] = tmp;             break;         } else {             if(heap[pivot] &lt; heap[pivot + 1]) pivot++;             if(heap[ppivot] &gt; heap[pivot]) break;             int tmp = heap[pivot];             heap[pivot] = heap[ppivot];             heap[ppivot] = tmp;         }     }     return val; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);          int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;= T; tc++) {         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ';         heapCnt = 0;         int N;         cin &gt;&gt; N;         for(int n = 0; n &lt; N; n++) {             int act;             cin &gt;&gt; act;             if(act == 1) {                 int num;                 cin &gt;&gt; num;                 Add(num);             } else {                 cout &lt;&lt; Pop() &lt;&lt; ' ';             }         }         cout &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Heap"],
        "url": "/swea/2930/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 3000. 중간값 구하기 (C++, 라이브러리 X)",
        "excerpt":"  Heap 기본문제   풀이   Max-Heap과 Min-Heap을 이용해서 중간값을 실시간으로 구할 수 있습니다.   Max-Heap과 Min-Heap을 따로 구현해주었습니다.   MinHeap에는 MaxHeap[0]보다 큰 값들만 넣어주고 작은 값들은 MaxHeap에 넣어줍니다.   Add와 Pop을 적절히 이용해 MinHeap의 크기 + 1 = MaxHeap의 크기가 되도록 하였습니다.   MaxHeap[0]에는 항상 중간값이 저장됩니다.   참고: 중앙값(Median) 찾기     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXN 200000  int N;  int maxHeap[MAXN + 2]; int minHeap[MAXN + 1];  int maxCnt, minCnt;  void AddMax(int val) {     int pivot = maxCnt;     maxHeap[maxCnt++] = val;          while(pivot &gt; 0) {         int ppivot = pivot;         pivot = pivot - 1 &gt;&gt; 1;         if(maxHeap[pivot] &lt; val) {             maxHeap[ppivot] = maxHeap[pivot];             maxHeap[pivot] = val;         } else return;     } }  void AddMin(int val) {     int pivot = minCnt;     minHeap[minCnt++] = val;          while(pivot &gt; 0) {         int ppivot = pivot;         pivot = pivot - 1 &gt;&gt; 1;         if(minHeap[pivot] &gt; val) {             minHeap[ppivot] = minHeap[pivot];             minHeap[pivot] = val;         } else return;     } }  int PopMax() {     int val = maxHeap[0];     maxHeap[0] = maxHeap[--maxCnt];      int pivot = 0;     while(true) {         int ppivot = pivot;         pivot = (pivot &lt;&lt; 1) + 1;          if(maxCnt &lt;= pivot) break;         if(maxCnt == pivot + 1) {             if(maxHeap[pivot] &gt; maxHeap[ppivot]) {                 int tmp = maxHeap[pivot];                 maxHeap[pivot] = maxHeap[ppivot];                 maxHeap[ppivot] = tmp;             } else break;         } else {             if(maxHeap[pivot] &lt; maxHeap[pivot + 1]) pivot++;             if(maxHeap[pivot] &gt; maxHeap[ppivot]) {                 int tmp = maxHeap[pivot];                 maxHeap[pivot] = maxHeap[ppivot];                 maxHeap[ppivot] = tmp;             } else break;         }     }     return val; }  int PopMin() {     int val = minHeap[0];     minHeap[0] = minHeap[--minCnt];      int pivot = 0;     while(true) {         int ppivot = pivot;         pivot = (pivot &lt;&lt; 1) + 1;          if(minCnt &lt;= pivot) break;         if(minCnt == pivot + 1) {             if(minHeap[pivot] &lt; minHeap[ppivot]) {                 int tmp = minHeap[pivot];                 minHeap[pivot] = minHeap[ppivot];                 minHeap[ppivot] = tmp;             } else break;         } else {             if(minHeap[pivot] &gt; minHeap[pivot + 1]) pivot++;             if(minHeap[pivot] &lt; minHeap[ppivot]) {                 int tmp = minHeap[pivot];                 minHeap[pivot] = minHeap[ppivot];                 minHeap[ppivot] = tmp;             } else break;         }     }     return val; }   int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);      int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;=T; tc++) {         int A;         cin &gt;&gt; N &gt;&gt; A;         maxCnt = minCnt = 0;         AddMax(A);         int sum = 0;         for(int n = 0; n &lt; N; n++) {             int X, Y;             cin &gt;&gt; X &gt;&gt; Y;             if(X &gt; maxHeap[0]) AddMin(X);             else AddMax(X);             if(Y &gt; maxHeap[0]) AddMin(Y);             else AddMax(Y);             if(maxCnt &lt; minCnt) AddMax(PopMin());             else if(maxCnt - 1 &gt; minCnt) AddMin(PopMax());             sum += maxHeap[0];             if(sum &gt;= 20171109) sum %= 20171109;         }         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; sum &lt;&lt; '\\n';     } }   Reference      중앙값(Median) 찾기  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Heap"],
        "url": "/swea/3000/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 10806. 수 만들기 (C++, 라이브러리 X)",
        "excerpt":"  Heap 기본문제   풀이   참고: [알고리즘] SW Expert Academy 10806. 수 만들기     실수   쉬프트 연산자를 사용할 때 대입 연산자 빼먹지 말기.   연산 순서: 산술연산자 -&gt; 쉬프트 연산자. (웬만하면 괄호를 쓸 것)   코드 GitHub   #include &lt;iostream&gt; using namespace std;  int A[10];  struct Node {     int left;     int cnt; } nodes[9000]; int nodeCnt;  bool Cmp(Node a, Node b) {     if(a.cnt == b.cnt) return a.left &lt; b.left;     else return a.cnt &lt; b.cnt; }  void Add(int left, int cnt) {     nodes[nodeCnt].left = left;     nodes[nodeCnt].cnt = cnt;     int pivot = nodeCnt;     nodeCnt++;     while(pivot &gt; 0) {         int ppivot = pivot;         pivot = (pivot - 1) &gt;&gt; 1;         if(Cmp(nodes[pivot], nodes[ppivot])) return;         nodes[ppivot] = nodes[pivot];         nodes[pivot].cnt = cnt;         nodes[pivot].left = left;     }     return; }  Node Pop() {     Node rev = nodes[0];      nodes[0] = nodes[--nodeCnt];      int pivot = 0;     while(true) {         int ppivot = pivot;         pivot = (pivot &lt;&lt; 1) + 1;         if(nodeCnt &lt;= pivot) break;         if(pivot + 1 == nodeCnt) {             if(Cmp(nodes[pivot], nodes[nodeCnt])) {                 nodes[ppivot] = nodes[pivot];                 nodes[pivot] = nodes[nodeCnt];             } else break;         } else {             if(Cmp(nodes[pivot+1], nodes[pivot])) pivot++;             if(Cmp(nodes[pivot], nodes[nodeCnt])) {                 nodes[ppivot] = nodes[pivot];                 nodes[pivot] = nodes[nodeCnt];             } else break;         }     }     return rev; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);      int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;=T; tc++) {         int N, K;         cin &gt;&gt; N;         for(int n = 0; n &lt; N; n++) cin &gt;&gt; A[n];         cin &gt;&gt; K;          int ans;         nodeCnt = 0;         Add(K, 0);         while(nodeCnt &gt; 0) {             Node node = Pop();             int cnt = node.cnt;             int left = node.left;             if(left == 0) {                 ans = cnt;                 break;             }             bool add = false;             for(int n = 0; n &lt; N; n++) {                 if(left &gt;= A[n]) {                     Add(left / A[n], cnt + (left % A[n]));                     add = true;                 }             }             if(!add) Add(0, cnt + left);         }          cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\\n';     } }   Reference      [알고리즘] SW Expert Academy 10806. 수 만들기  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Heap"],
        "url": "/swea/10806/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 1249. 보급로 (C++, 라이브러리 X)",
        "excerpt":"  Heap 기본문제   풀이   복구 시간을 기준으로 Min Heap을 만듦.   복구 시간이 최소인 지점(Pop)에서 상하좌우로 이동했을 경우 좌표와 복구 시간을 Min Heap에 넣어줌(Add)   이렇게 되면 복구 시간이 최소인 지점이 N-1, N-1 일때 복구 시간이 정답이 됨.   추가로, 최소 복구 시간으로 한번 탐색했던 지점은 체크하여 다시 탐색하지 않도록 함.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  const int dr[4] = {0, 0, -1, 1}; const int dc[4] = {-1, 1, 0, 0};  #define MAXN 100  int map[MAXN][MAXN]; int N;  struct Node {     int recovery;     int r, c; } nodes[MAXN * MAXN]; int nodeCnt; bool check[MAXN][MAXN];  bool CmpSwap(int idxA, int idxB) {     if(nodes[idxA].recovery &gt; nodes[idxB].recovery) {         Node tmp = nodes[idxA];         nodes[idxA] = nodes[idxB];         nodes[idxB] = tmp;         return true;     } else return false;      }  void Init() {     nodeCnt = 0;     for(int i = 0; i &lt; N; i++) {         for(int j = 0; j &lt; N; j++) {             check[i][j] = false;         }     }     return; }  void Add(int rec, int r, int c) {     if(check[r][c]) return;     nodes[nodeCnt].recovery = rec;     nodes[nodeCnt].r = r;     nodes[nodeCnt].c = c;     int pivot = nodeCnt;     nodeCnt++;     while(pivot &gt; 0) {         int ppivot = pivot;         pivot = (pivot - 1) &gt;&gt; 1;         if(!CmpSwap(pivot, ppivot)) break;     }     return; }  Node Pop() {     Node rev = nodes[0];     check[rev.r][rev.c] = true;     nodes[0] = nodes[--nodeCnt];     int pivot = 0;     while(true) {         int ppivot = pivot;         pivot = (pivot &lt;&lt; 1) + 1;         if(pivot &gt;= nodeCnt) break;         else if(pivot + 1 == nodeCnt) {             if(!CmpSwap(ppivot, pivot)) break;         } else {             if(nodes[pivot].recovery &gt; nodes[pivot + 1].recovery) pivot++;             if(!CmpSwap(ppivot, pivot)) break;         }     }     return rev; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     freopen(\"input.txt\", \"r\", stdin);      int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;= T; tc++) {         cin &gt;&gt; N;         for(int i = 0; i &lt; N; i++) {             for(int j = 0; j &lt; N; j++) {                 char a;                 cin &gt;&gt; a;                 map[i][j] = a - '0';             }         }         Init();         Add(0, 0, 0);         int ans;         while(nodeCnt &gt; 0) {             Node node = Pop();             if(node.r == N - 1 &amp;&amp; node.c == N -1) {                 ans = node.recovery;                 break;             }             for(int i = 0; i &lt; 4; i++) {                 int nr = node.r + dr[i];                 int nc = node.c + dc[i];                 if(nr &lt; 0 || nr &gt;= N || nc &lt; 0 || nc &gt;= N) continue;                 int nrec = node.recovery + map[nr][nc];                 Add(nrec, nr, nc);             }         }         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Heap"],
        "url": "/swea/1249/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 1256. K번째 접미어 (C++, 라이브러리 X)",
        "excerpt":"  Trie 기본문제   풀이   Trie를 구현하고, 각각의 노드에 해당 노드로 시작하는 단어의 개수(cnt)와 해당 노드로 끝나는 단어의 존재 여부(end)를 저장함.   모든 단어를 Trie에 넣고, cnt가 K를 넘어가지 않도록 탐색.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXM 400  char str[MAXM];  struct TrieNode {     int cnt;     bool end;     TrieNode* next[26];      TrieNode* Alloc() {         cnt = 0;         end = false;         for(int i = 0; i &lt; 26; i++) next[i] = nullptr;         return this;     } } nodes[MAXM * MAXM]; int nodeCnt; TrieNode head;  void Init() {     nodeCnt = 0;     head.Alloc(); }  void Add(char* s) {     int pivot = 0;     TrieNode* node = &amp;head;     while(s[pivot]) {         int alpn = s[pivot] - 'a';         if(!node-&gt;next[alpn]) {             node-&gt;next[alpn] = nodes[nodeCnt++].Alloc();         }         node-&gt;cnt++;         node = node-&gt;next[alpn];         pivot++;     }     node-&gt;cnt++;     node-&gt;end = true;     return; }  void Find(int k) {     TrieNode* node = &amp;head;     if(k &gt; node-&gt;cnt) cout &lt;&lt; \"none\";      while(true) {         if(node-&gt;end) k--;         if(k == 0) break;         int left = k;         for(int i = 0; i &lt; 26; i++) {             k = left;             if(node-&gt;next[i]) left -= node-&gt;next[i]-&gt;cnt;             if(left &lt;= 0) {                 node = node-&gt;next[i];                 cout &lt;&lt; (char)(i + 'a');                 break;             }         }     }     return; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     freopen(\"input.txt\", \"r\", stdin);     int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;= T; tc++) {         int K;         cin &gt;&gt; K;         cin &gt;&gt; str;         Init();         for(int i = 0; str[i]; i++) Add(&amp;str[i]);         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ';         Find(K);         cout &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Trie"],
        "url": "/swea/1256/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 3135. 홍준이의 사전놀이 (C++, 라이브러리 X)",
        "excerpt":"  Trie 기본문제   풀이   Trie를 구현하고, 각각의 노드에 해당 노드로 시작하는 단어의 개수(cnt)를 저장함.   query함수는 해당 단어를 찾고, cnt를 반환.   해당 단어가 없을 경우 0을 반환     코드 GitHub   struct TrieNode {     int cnt;     TrieNode* next[26];      TrieNode* Alloc() {         cnt = 0;         for(int i = 0; i &lt; 26; i++) next[i] = nullptr;         return this;     } } nodes[1000000]; int nodeCnt; TrieNode head;  void init(void) {     nodeCnt = 0;     head.Alloc(); }  void insert(int buffer_size, char *buf) {     TrieNode* node = &amp;head;     for(int i = 0; i &lt; buffer_size; i++) {         int anum = buf[i] - 'a';         if(!node-&gt;next[anum]) node-&gt;next[anum] = nodes[nodeCnt++].Alloc();         node-&gt;cnt++;         node = node-&gt;next[anum];     }     node-&gt;cnt++;     return; }  int query(int buffer_size, char *buf) {     TrieNode* node = &amp;head;     for(int i = 0; i &lt; buffer_size; i++) {         int anum = buf[i] - 'a';         if(!node-&gt;next[anum]) return 0;         node = node-&gt;next[anum];     } \treturn node-&gt;cnt; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Trie"],
        "url": "/swea/3135/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 1257. K번째 문자열 (C++, 라이브러리 X)",
        "excerpt":"  Trie 기본문제   풀이   K번째 접미어와 매우 유사함.   Add할 때에 중복을 체크하는 코드만 추가.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXM 400  char str[MAXM];  struct TrieNode {     int cnt;     bool end;     TrieNode* next[26];      TrieNode* Alloc() {         cnt = 0;         end = false;         for(int i = 0; i &lt; 26; i++) next[i] = nullptr;         return this;     } } nodes[MAXM * MAXM]; int nodeCnt;  TrieNode head;  void Init() {     head.Alloc();     nodeCnt = 0; }  void Add(int start, int end) {     TrieNode* node = &amp;head;     bool exist = true;     for(int i = start; i &lt; end; i++) {         int anum = str[i] - 'a';         if(!node-&gt;next[anum]) {             exist = false;             break;         }         node = node-&gt;next[anum];     }      if(exist &amp;&amp; node-&gt;end) return;     node = &amp;head;     for(int i = start; i &lt; end; i++) {         int anum = str[i] - 'a';         if(!node-&gt;next[anum]) node-&gt;next[anum] = nodes[nodeCnt++].Alloc();         node-&gt;cnt++;         node = node-&gt;next[anum];     }     node-&gt;cnt++;     node-&gt;end = true;     return; }  void Find(int k) {     TrieNode* node = &amp;head;     if(node-&gt;cnt &lt; k) {         cout &lt;&lt; \"none\";         return;     }     while(true) {         if(node-&gt;end) k--;         if(k == 0) return;          for(int i = 0; i &lt; 26; i++) {             if(!node-&gt;next[i]) continue;             k -= node-&gt;next[i]-&gt;cnt;             if(k &lt; 1) {                 k += node-&gt;next[i]-&gt;cnt;                 node = node-&gt;next[i];                 cout &lt;&lt; (char)('a' + i);                 break;             }         }     }     return; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     freopen(\"input.txt\", \"r\", stdin);      int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;= T; tc++) {         int K;         cin &gt;&gt; K &gt;&gt; str;         int M = 0;         for(int i = 0; str[i]; i++) M++;          Init();         for(int i = 0; i &lt; M; i++)             for(int j = i + 1; j &lt; M + 1; j++)                 Add(i, j);         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ';         Find(K);         cout &lt;&lt; '\\n';     }     return 0; }   Reference      [SWEA] 1256. K번째 접미어 (C++, 라이브러리 X)  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Trie"],
        "url": "/swea/1257/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 4753 호둥이의 단어찾기 (C++, 라이브러리 X)",
        "excerpt":"  Trie 기본문제   풀이   이전 Trie 기본문제들과 동일하게 카운트를 가진 Trie를 구현함.   비교횟수는 탐색하면서 거쳐온 노드의 카운트의 합.   단어의 순서가 사전순이 아니라 입력순이기 때문에 사전에 단어가 존재할 경우는 입력 단계에서 답을 미리 구해놓아야함.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXN 30000 #define MAXM 30000  struct TrieNode {     int cnt;     int ans;     TrieNode* next[26];      TrieNode* Alloc() {         cnt = 0;         ans = -1;         for(int i = 0; i &lt; 26; i++) next[i] = nullptr;         return this;     } } nodes[MAXN * 30]; int nodeCnt; TrieNode head;  void Init() {     nodeCnt = 0;     head.Alloc(); }  void Add (char* str) {     TrieNode* node = &amp;head;     int ans = 0;     for(int i = 0; str[i]; i++) {         node-&gt;cnt++;         ans += node-&gt;cnt;         int anum = str[i] - 'a';         if(!node-&gt;next[anum]) node-&gt;next[anum] = nodes[nodeCnt++].Alloc();         node = node-&gt;next[anum];     }     node-&gt;cnt++;     ans += node-&gt;cnt;     node-&gt;ans = ans;     return; }  int Find(char* str) {     TrieNode* node = &amp;head;     int ans = 0;     bool none = false;     for(int i = 0; str[i]; i++) {         ans += node-&gt;cnt;         int anum = str[i] - 'a';         if(!node-&gt;next[anum]) {             none = true;             break;         }         node = node-&gt;next[anum];     }     if(none) return ans;     if(node-&gt;ans == -1) return ans + node-&gt;cnt;     return node-&gt;ans; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     // freopen(\"input.txt\", \"r\", stdin);      int T;     cin &gt;&gt; T;     char str[30];     for(int tc = 1; tc &lt;= T; tc++) {         int N, M;         cin &gt;&gt; N;         Init();         for(int n = 0; n &lt; N; n++) {             cin &gt;&gt; str;             Add(str);         }         cin &gt;&gt; M;         long long ans = 0;         for(int m = 0; m &lt; M; m++) {             cin &gt;&gt; str;             ans += Find(str);         }         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Trie"],
        "url": "/swea/4753/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 3814 평등주의 (C++, 라이브러리 X)",
        "excerpt":"  Divide-and-conquer(분할정복) 실전문제   풀이   최대값이 최소가 되도록 하는 문제는 대부분 Binary Search(이분탐색)으로 풀 수 있다.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXN 100000  int N, K;  int nums[MAXN]; int numsTmp[MAXN];  bool Verify(int val) {     int k = K;     for(int n = 0; n &lt; N; n++) {         int del = 0;         if(n &gt; 0) del = nums[n] - numsTmp[n - 1];         if(n &lt; N - 1) {             int tmp = nums[n] - nums[n + 1];             if(tmp &gt; del) del = tmp;         }         if(del &gt; val) {             numsTmp[n] = nums[n] - del + val;             k -= del - val;         } else numsTmp[n] = nums[n];         if(k &lt; 0) return false;     }     for(int n = N - 1; n &gt;= 0; n--) {         int del = 0;         if(n &gt; 0) del = numsTmp[n] - numsTmp[n - 1];         if(n &lt; N - 1) {             int tmp = numsTmp[n] - numsTmp[n + 1];             if(tmp &gt; del) del = tmp;         }         if(del &gt; val) {             numsTmp[n] = numsTmp[n] - del + val;             k -= del - val;         }         if(k &lt; 0) return false;     }     return true; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);      int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;= T; tc++) {         cin &gt;&gt; N &gt;&gt; K;         for(int n = 0; n &lt; N; n++) cin &gt;&gt; nums[n];          int max = 0;         for(int n = 0; n &lt; N - 1; n++) {             int del = nums[n] - nums[n+1];             if(del &lt; 0) del = 0 - del;             if(max &lt; del) max = del;         }          int l = 0, r = max;         while(l &lt; r) {             int m = (l + r) / 2;             if(Verify(m)) r = m;             else l = m + 1;         }         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","DAC"],
        "url": "/swea/3814/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 3813 그래도 수명이 절반이 되어서는... (C++, 라이브러리 X)",
        "excerpt":"  Divide-and-conquer(분할정복) 실전문제   풀이   최대값이 최소가 되도록 하는 문제는 대부분 Binary Search(이분탐색)으로 풀 수 있다.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXN 200000  int W[MAXN], S[MAXN]; int N, K;  bool Verify(int val) {     int pivot = -1;     for(int k = 0; k &lt; K; k++) {         for(int s = 0; s &lt; S[k]; s++) {             pivot++;             if(pivot == N) return false;             if(W[pivot] &gt; val) {                 k--;                 break;             }         }     }     return true; }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;= T; tc++) {         cin &gt;&gt; N &gt;&gt; K;         for(int n = 0; n &lt; N; n++) cin &gt;&gt; W[n];         for(int k = 0; k &lt; K; k++) cin &gt;&gt; S[k];          int l = 0, r = 200000;         while(l &lt; r) {             int m = (l + r) / 2;             if(Verify(m)) r = m;             else l = m + 1;         }         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","DAC"],
        "url": "/swea/3813/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 2948 문자열 교집합 (C++, 라이브러리 X)",
        "excerpt":"  Hash 기본문제   풀이   첫번째 집합으로 Hash Table을 만든다.   두번째 집합의 문자열들이 Hash Table에 존재하는지 확인한다.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXN 100000 #define MAX_LENGTH 51 #define HASH_SIZE (1 &lt;&lt; 18) #define DIV (HASH_SIZE - 1)  void StrCpy(char *empty, char *str) {     while(*str) *empty++ = *str++;     *empty = 0;     return; }  bool StrCmp(char *strA, char *strB) {     while(*strA) {         if(*strA++ != *strB++) return false;     }     return *strA == *strB; }  int GetHash(char* str) {     unsigned long long hash = 5381;     while(*str) {         hash = (hash &lt;&lt; 5) + hash + *str - 'a';         *str++;     }     return (int)hash &amp; DIV;  }  struct HashNode {     char str[MAX_LENGTH];     HashNode* next;     HashNode* Alloc(char *_str, HashNode* _next) {         StrCpy(str, _str);         next = _next;         return this;     } } nodes[MAXN];  HashNode* hashTable[HASH_SIZE];  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);      int T;     cin &gt;&gt; T;     int N, M;     char str[MAX_LENGTH];     for(int tc = 1 ; tc &lt;= T; tc++) {         cin &gt;&gt; N &gt;&gt; M;         int nodeCnt = 0;         for(int i = 0; i &lt; HASH_SIZE; i++) hashTable[i] = nullptr;         for(int n = 0; n &lt; N; n++) {             cin &gt;&gt; str;             int hash = GetHash(str);             hashTable[hash] = nodes[nodeCnt++].Alloc(str, hashTable[hash]);         }         int ans = 0;         for(int m = 0; m &lt; M; m++) {             cin &gt;&gt; str;             int hash = GetHash(str);             HashNode* node = hashTable[hash];             while(node) {                 if(StrCmp(node-&gt;str, str)) {                     ans++;                     break;                 } else node = node-&gt;next;             }         }         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Hash"],
        "url": "/swea/2948/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 4038. 단어가 등장하는 횟수 (C++, 라이브러리 X)",
        "excerpt":"  Hash 기본문제   풀이   Hash를 사용하지 않고 KMP 알고리즘을 사용했습니다.   참고: KMP : 문자열 검색 알고리즘   실수   테스트 케이스를 여러번 실행할 때에는 전역변수 초기화를 잘 해줄 것.     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXB 500001 #define MAXS 100001  char B[MAXB], S[MAXS]; int P[MAXS];  void CalcP() {     P[0] = 0;     for(int i = 1; S[i]; i++) {         int j = P[i-1];         while(j &gt; 0) {             if(S[i] == S[j]) break;             j = P[j-1];         }         if(S[i] == S[j]) P[i] = j + 1;         else P[i] = 0;     } }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);      int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;= T; tc++) {         cin &gt;&gt; B &gt;&gt; S;         CalcP();          int piv = 0, cnt = 0, ans = 0;         while(B[piv]) {             if(B[piv] == S[cnt]) {                 if(!S[cnt+1]) {                     // Find                     ans++;                     cnt = P[cnt];                 } else cnt++;                 piv++;             } else if(cnt &gt; 0) cnt = P[cnt-1];             else piv++;         }         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Hash"],
        "url": "/swea/4038/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 7091. 은기의 아주 큰 그림 (C++, 라이브러리 X)",
        "excerpt":"  Hash 기본문제   풀이   Rabin-Karp 알고리즘을 사용하여 그림의 해시값을 구하여 은기와 선생님의 그림을 비교한다.   먼저 가로의 해시값을 구하고 가로의 해시값으로 세로의 해시값을 구한다.   실수   가로와 세로에 같은 Hash function을 사용하면 전체 Hash function이 대각선으로 대칭적인 모양이 된다.   따라서 가로와 세로에 각각 다른 Hash function을 사용하여 충돌을 피해야한다.   (한참동안 오버플로우가 문제인 줄 알고 삽질을 오래 했다… 안풀릴 땐 다시 천천히 살펴보자!)     코드 GitHub   #include &lt;iostream&gt; using namespace std;  #define MAXN 2000 #define HASH_SIZE (1 &lt;&lt; 30) #define DIV (HASH_SIZE - 1)  int H, W, N, M;  int myPic[MAXN][MAXN], samPic[MAXN][MAXN]; int samHash[MAXN][MAXN], tmp[MAXN][MAXN];  int CalcMul(int num, int shift) {     unsigned long long rev = 1;     for(int i = 1; i &lt; num; i++) {         rev = (rev &lt;&lt; shift) + rev;     }     return (int) (rev &amp; DIV); }  int GetHash(int* piv, int num, int shift) {     unsigned long long hash = 0;     for(int i = 0; i &lt; num; i++) {         hash = (hash &lt;&lt; shift) + hash + *piv++;     }     return (int) (hash &amp; DIV); }  int GetNext(int prev, int sub, int mul, int add, int shift) {     unsigned long long hash = prev - (sub * mul);     hash = (hash &lt;&lt; shift) + hash + add;     return (int) (hash &amp; DIV); }  int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     int T;     cin &gt;&gt; T;     for(int tc = 1; tc &lt;= T; tc++) {         cin &gt;&gt; H &gt;&gt; W &gt;&gt; N &gt;&gt; M;         for(int h = 0; h &lt; H; h++) for(int w = 0; w &lt; W; w++) {             char a;             cin &gt;&gt; a;             if(a == 'o') myPic[h][w] = 1;             else myPic[h][w] = 0;         }         for(int n = 0; n &lt; N; n++) for(int m = 0; m &lt; M; m++) {             char a;             cin &gt;&gt; a;             if(a == 'o') samPic[n][m] = 1;             else samPic[n][m] = 0;         }          // Get My Hash         for(int i = 0; i &lt; H; i++) tmp[0][i] = GetHash(myPic[i], W, 4);         int myHash = GetHash(tmp[0], H, 5);          // Get Sam Hash         int mulC = CalcMul(W, 4);         int mulR = CalcMul(H, 5);         for(int i = 0; i &lt; N; i++) {             tmp[0][i] = GetHash(samPic[i], W, 4);             for(int j = 1; j &lt; M - W + 1; j++) {                 tmp[j][i] = GetNext(tmp[j-1][i], samPic[i][j-1], mulC, samPic[i][j+W-1], 4);             }         }         for(int i = 0; i &lt; M - W + 1; i++) {             samHash[0][i] = GetHash(tmp[i], H, 5);             for(int j = 1; j &lt; N - H + 1; j++) {                 samHash[j][i] = GetNext(samHash[j-1][i], tmp[i][j-1], mulR, tmp[i][j+H-1], 5);             }         }          // Compare         int cnt = 0;         for(int i = 0; i &lt; N - H + 1; i++) for(int j = 0; j &lt; M - W + 1; j++)             if(samHash[i][j] == myHash) cnt++;         cout &lt;&lt; '#' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; '\\n';     }     return 0; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Hash"],
        "url": "/swea/7091/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 12526. 자동완성 (C++, 라이브러리 X)",
        "excerpt":"  B형 실전 문제   풀이   Trie를 만들고 카운트(cnt), 밴 여부(ban), 추천 노드(best) 를 저장.   input을 할 때마다 카운트를 1씩 더하고, 부모 노드를 순회하면서 best와 비교 및 교체.   ban을 하면 ban을 true로 해서 추천되지 않도록 하고, 부모 노드를 순회하면서 해당 노드를 best로 갖고 있으면 best를 다시 찾아줌.   recommend를 하면 해당 노드로 찾아가 best를 리턴, best가 ban이거나 cnt가 0일경우 input값을 리턴.   실수   MAX_NODE 값을 넉넉히 줄것. (최대값을 정확히 계산하면 좋겠지만 넉넉히 주는 것이 맘편함!)   ban한 값을 추천하지 않는 로직을 빼먹음 (끝까지 집중해서 코딩할 것)     코드 GitHub   #define MAX_NODE 200000  void mstrcpy(char dst[], const char src[]) { \tint c = 0; \twhile ((dst[c] = src[c]) != 0) \t\t++c; }  int mstrlen(const char str[]) { \tint ret = 0; \twhile (str[ret]) \t\t++ret; \treturn ret; }  int mstrcmp(const char str1[], const char str2[]) { \tint c = 0; \twhile (str1[c] != 0 &amp;&amp; str1[c] == str2[c]) \t\t++c; \treturn str1[c] - str2[c]; }  struct TrieNode {     char str[20];     int cnt, time;     TrieNode *best, *parent, *next[26];     bool ban;      TrieNode* Alloc(TrieNode *_parent) {         str[0] = 0;         cnt = 0;         time = 0;         best = this;         parent = _parent;         for(int i = 0; i &lt; 26; i++) next[i] = nullptr;         ban = false;          return this;     }      void init(char *_str, int _time, bool _ban) {         if(ban) return;         mstrcpy(str, _str);         time = _time;         cnt = 1;         ban = _ban;          return;     }      void Add(int _time) {         time = _time;         cnt ++;         return;     }      void Ban() {         ban = true;          return;     } } nodes[MAX_NODE]; int nodeCnt; TrieNode* head; int wordCnt;  bool nodecmp(TrieNode* a, TrieNode* b) {     if(!b) return true;     if(a-&gt;ban) return false;     if(b-&gt;ban) return true;     if(a-&gt;cnt &gt; b-&gt;cnt) return true;     if(a-&gt;cnt &lt; b-&gt;cnt) return false;     if(a-&gt;time &gt; b-&gt;time) return true;     return false; }  void init() {     nodeCnt = 0;     wordCnt = 0;     head = nodes[nodeCnt++].Alloc(nullptr);      return; }  void inputWord(char mWord[20]) {     TrieNode* pivot = head;     char* a = mWord;      while(*a) {         int num = *a++ - 'a';         if(!pivot-&gt;next[num])              pivot-&gt;next[num] = nodes[nodeCnt++].Alloc(pivot);         pivot = pivot-&gt;next[num];     }     if(pivot-&gt;cnt) pivot-&gt;Add(wordCnt++);     else pivot-&gt;init(mWord, wordCnt++, false);      TrieNode* pivot2 = pivot;     while(pivot2) {         if(nodecmp(pivot, pivot2-&gt;best)) pivot2-&gt;best = pivot;         pivot2 = pivot2-&gt;parent;     }      return; }  int recommend(char mUser[20], char mAnswer[20]) {     TrieNode *pivot = head;     char *a = mUser;     while(*a) {         int num = *a++ - 'a';         if(!pivot-&gt;next[num]) {             mstrcpy(mAnswer, mUser);             return mstrlen(mUser);         }         pivot = pivot-&gt;next[num];     }     pivot = pivot-&gt;best;     if(pivot-&gt;cnt == 0 || pivot-&gt;ban) {         mstrcpy(mAnswer, mUser);         return mstrlen(mUser);     }     mstrcpy(mAnswer, pivot-&gt;str);  \treturn mstrlen(mAnswer); }  void banWord(char mWord[20]) {     TrieNode *pivot = head;     char *a = mWord;     while(*a) {         int num = *a++ - 'a';         if(!pivot-&gt;next[num])             pivot-&gt;next[num] = nodes[nodeCnt++].Alloc(pivot);         pivot = pivot-&gt;next[num];     }     pivot-&gt;Ban();      TrieNode *pivot2 = pivot;     while(pivot2) {         if(pivot2-&gt;best == pivot) {             for(int i = 0; i &lt; 26; i++) {                 if(pivot2-&gt;next[i]) {                     if(nodecmp(pivot2-&gt;next[i]-&gt;best, pivot2-&gt;best))                         pivot2-&gt;best = pivot2-&gt;next[i]-&gt;best;                 }             }             pivot2 = pivot2-&gt;parent;         } else break;     }      return;  }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Trie"],
        "url": "/swea/12526/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 9467. 문자열 암호화 (C++, 라이브러리 X)",
        "excerpt":"  B형 실전 문제   풀이   바꾸는 문자열이 3글자로 고정돼있으므로 Hash를 이용하면 1대1 매핑이 가능하다.   문자열의 크기 (50000), change 호출 횟수(50000) 을 고려하면 완전 탐색은 50000 * 50000 로 시간초과가 난다.   그래서 Hash Table을 Linked List 로 만들어 원하는 Hash에 바로 접근할 수 있도록 한다.   Worst Case   Hash Table을 이용해도 한번의 change 호출에 문자열 교체가 매우 많이 일어나는 경우에는 50000 * 50000 / 3 으로 시간초과가 날 수밖에 없다.   그러나 이러한 극단적인 Worst Case는 고려하지 않고, 입력이 랜덤으로 들어온다고 가정하여 푸는 것이 좋다고 한다.   실수   원래는 Single Linked List를 구현하였다.   구현 도중에 Double Linked List로 설계를 바꿨다. (삽입과 삭제가 빈번하게 일어나므로 Double을 사용하는게 좋다)   prev를 뒤늦게 추가하는 과정에서 실수가 있었다.   중간에 설계를 바꿀 경우 실수할 확률이 높으므로 처음부터 철처하게 설계하도록 하자.     코드 GitHub   #define MAXN 50005 #define HASH_SIZE (1&lt;&lt;15)  struct Node {     int idx;     Node* next;     Node* prev;      Node* Alloc(int _idx,Node* _prev, Node* _next) {         idx = _idx;         prev = _prev;         next = _next;         if(_next) _next-&gt;prev = this;         if(_prev) _prev-&gt;next = this;          return this;     } } nodes[MAXN];  char str[MAXN]; int N; Node hashTable[HASH_SIZE];  int getHash(char *A) {     int hash = *A++ - 'a';     hash = (hash &lt;&lt; 5) + *A++ - 'a';     hash = (hash &lt;&lt; 5) + *A - 'a';     return hash; }  int getNext(int hash, char *A) {     hash &amp;= (1 &lt;&lt; 10) - 1;     hash = (hash &lt;&lt; 5) + *(A+3) - 'a';      return hash; }  int getPrev(int hash, char *A) {     hash = hash &gt;&gt; 5;     hash += (*A - 'a') &lt;&lt; 10;      return hash; }  void mstrcpy(char *dst, char *src) {     while(*src) *dst++ = *src++;     *dst = 0;     return; }  void InputHash(Node* node, int hash) {     Node* pivot = &amp;hashTable[hash];     while(pivot-&gt;next) {         if(pivot-&gt;next-&gt;idx &gt; node-&gt;idx) break;         pivot = pivot-&gt;next;     }     node-&gt;next = pivot-&gt;next;     pivot-&gt;next = node;     node-&gt;prev = pivot;     if(node-&gt;next) node-&gt;next-&gt;prev = node;      return; }  void init(int _N, char init_string[]) {     N = _N;     mstrcpy(str, init_string);     for(int i = 0; i &lt; HASH_SIZE; i++) hashTable[i].Alloc(-1, nullptr, nullptr);     int hash = getHash(init_string + N - 3);     hashTable[hash].next = nodes[N - 3].Alloc(N - 3, &amp;hashTable[hash], hashTable[hash].next);     for(int i = N - 4; i &gt;= 0; i--) {         hash = getPrev(hash, &amp;init_string[i]);         hashTable[hash].next = nodes[i].Alloc(i, &amp;hashTable[hash], hashTable[hash].next);     }      return; }  int change(char A[], char B[]) {      int hashA = getHash(A);      Node *pivot = hashTable[hashA].next;     hashTable[hashA].next = nullptr;     int prevIdx = -3;      int cnt = 0;     while(pivot) {         pivot-&gt;prev = nullptr;         if(prevIdx + 3 &gt; pivot-&gt;idx) {             Node* tmp = pivot-&gt;next;             InputHash(pivot, hashA);             pivot = tmp;             continue;         }         cnt++;         prevIdx = pivot-&gt;idx;         str[pivot-&gt;idx] = B[0];         str[pivot-&gt;idx+1] = B[1];         str[pivot-&gt;idx+2] = B[2];         Node* tmp = pivot-&gt;next;         while(tmp &amp;&amp; prevIdx + 3 &gt; tmp-&gt;idx) {             tmp = tmp-&gt;next;         }         int hash = -1;         for(int i = pivot-&gt;idx - 2; i &lt;= pivot-&gt;idx + 2; i++) {             if(i &lt; 0) continue;             else if(i == N - 2) break;             if(hash == -1) hash = getHash(str + i);             else hash = getNext(hash, str + i - 1);              if(nodes[i].prev) nodes[i].prev-&gt;next = nodes[i].next;             if(nodes[i].next) nodes[i].next-&gt;prev = nodes[i].prev;             Node* aa = &amp;hashTable[33];              InputHash(nodes + i, hash);         }         pivot = tmp;     }      return cnt; }  void result(char ret[]) {     mstrcpy(ret, str);     return; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Hash"],
        "url": "/swea/9467/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 9468. 친구 추천 (C++, 라이브러리 X)",
        "excerpt":"  B형 실전 문제   풀이   Graph와 Bucket을 이용했다.   Graph와 Linked List를 이용해서 Edge를 만들면 Edge를 Delete할 때 해당 node의 모든 edge를 탐색하야하므로 시간초과가 난다.   그렇다고해서 N * N의 edge 배열을 만들기엔 N이 10000으로 너무 커서 메모리가 부족하다.   대안으로 Bucket을 사용했다.   64크기의 Bucket으로 Linked List를 구현하면, delete할 때에는 최대 64개의 edge만 탐색하면 되고, 필요한 메모리 공간이 N * N / 64 로 크게 준다.   실수   최대 edge의 개수가 1,000,000개 인데, 100,000개로 오타가 났다.   MAX 상수의 값을 다시 한번 체크하자.     코드 GitHub   //#include &lt;stdio.h&gt;  #define MAXN 10001 #define MAXE 1000001 #define BUCKET_SIZE 64 #define BUCKET_SHIFT 6   struct Edge { \tint end; \tEdge* next;  \tEdge* Alloc(int _end, Edge* _next) { \t\tend = _end; \t\tnext = _next;  \t\treturn this; \t} }edges[MAXE]; int edgeCnt;  struct Node { \tEdge edges[(MAXN &gt;&gt; BUCKET_SHIFT) + 1]; } nodes[MAXN];  int N;  int check[MAXN];  //void showFriends() { //\tfor (int n = 0; n &lt; N; n++) { //\t\tprintf(\"%d: \", n); //\t\tEdge* pivot = &amp;nodes[n].edges[0]; //\t\twhile (pivot-&gt;next) { //\t\t\tif (pivot-&gt;next-&gt;end != -1) printf(\"%d \", pivot-&gt;next-&gt;end); //\t\t\tpivot = pivot-&gt;next; //\t\t} //\t\tprintf(\"\\n\"); //\t} //}   void init(int _N) { \tedgeCnt = 0; \tN = _N + 1; \tfor (int n = 1; n &lt; N; n++) { \t\tfor (int i = 0; i &lt; (N &gt;&gt; BUCKET_SHIFT) + 1; i++) { \t\t\tif(i == (N &gt;&gt; BUCKET_SHIFT)) nodes[n].edges[i].Alloc(-1, nullptr); \t\t\telse nodes[n].edges[i].Alloc(-1, &amp;nodes[n].edges[i + 1]); \t\t} \t}  \treturn; }  void add(int id, int F, int ids[]) { \tint bnum = id &gt;&gt; BUCKET_SHIFT; \t \tfor (int i = 0; i &lt; F; i++) { \t\tint fbnum = ids[i] &gt;&gt; BUCKET_SHIFT; \t\tnodes[id].edges[fbnum].next = edges[edgeCnt++].Alloc(ids[i], nodes[id].edges[fbnum].next); \t\tnodes[ids[i]].edges[bnum].next = edges[edgeCnt++].Alloc(id, nodes[ids[i]].edges[bnum].next); \t}  \treturn; }  void del(int id1, int id2) { \tint bnum1 = id1 &gt;&gt; BUCKET_SHIFT; \tint bnum2 = id2 &gt;&gt; BUCKET_SHIFT;  \tEdge* pivot = &amp;nodes[id1].edges[bnum2]; \twhile (true) { \t\tif (pivot-&gt;next-&gt;end == id2) break; \t\tpivot = pivot-&gt;next; \t} \tpivot-&gt;next = pivot-&gt;next-&gt;next;  \tpivot = &amp;nodes[id2].edges[bnum1]; \twhile (true) { \t\tif (pivot-&gt;next-&gt;end == id1) break; \t\tpivot = pivot-&gt;next; \t} \tpivot-&gt;next = pivot-&gt;next-&gt;next;  \treturn; }  int recommend(int id, int list[]) { \tfor (int n = 1; n &lt; N; n++) { \t\tcheck[n] = 0; \t} \tcheck[id] = -1;  \tEdge* pivot = &amp;nodes[id].edges[0];  \twhile (pivot-&gt;next) { \t\tif (pivot-&gt;next-&gt;end != -1) { \t\t\tcheck[pivot-&gt;next-&gt;end] = -1; \t\t\tEdge* pivot2 = &amp;nodes[pivot-&gt;next-&gt;end].edges[0]; \t\t\twhile (pivot2-&gt;next) { \t\t\t\tif (pivot2-&gt;next-&gt;end != -1) { \t\t\t\t\tif (check[pivot2-&gt;next-&gt;end] != -1) check[pivot2-&gt;next-&gt;end]++; \t\t\t\t} \t\t\t\tpivot2 = pivot2-&gt;next; \t\t\t} \t\t} \t\tpivot = pivot-&gt;next; \t}  \tint max[5] = { 0, }; \tfor (int n = 1; n &lt; N; n++) { \t\tint c = check[n]; \t\tif (c &gt; max[4]) {  \t\t\tmax[4] = c; \t\t\tlist[4] = n; \t\t} \t\tfor (int i = 4; i &gt; 0; i--) { \t\t\tif (max[i] &gt; max[i - 1]) { \t\t\t\tint tmp = max[i]; \t\t\t\tmax[i] = max[i - 1]; \t\t\t\tmax[i - 1] = tmp; \t\t\t\ttmp = list[i]; \t\t\t\tlist[i] = list[i - 1]; \t\t\t\tlist[i - 1] = tmp; \t\t\t} \t\t} \t} \tint cnt = 0; \tfor (int i = 0; i &lt; 5; i++) { \t\tif (max[i] &gt; 0) cnt++; \t}  \treturn cnt; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Graph"],
        "url": "/swea/9468/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 11716. 도서관 정리 (C++, 라이브러리 X)",
        "excerpt":"  B형 실전 문제   풀이   도서의 제목을 저장한는 Trie와 분류를 저장하는 배열을 만든다.   분류는 3글자 이하이므로 Hash를 통해 1대1 대응시킬 수 있다.   또한 테스트케이스당 500개 이하의 분류가 존재하므로 구역의 수(100) * 분류의 수(500) 의 2차원 배열을 만들 수 있다.   실수   Double Linked List에서 삽입 및 삭제를 할때 prev와 next 노드도 빼먹지 말고 업데이트 해주자.     코드 GitHub   #define MAX_N\t\t\t5  #define MAX_NAME_LEN\t7 #define MAX_TAG_LEN\t\t4  #define TAG_HASH        (1 &lt;&lt; 18) #define MAX_BOOK        50000  struct TrieNode {     int bookNum;     TrieNode* nexts[52];      TrieNode* Alloc(int _bookNum) {         bookNum = _bookNum;         for(int i = 0; i &lt; 52; i++) nexts[i] = nullptr;          return this;     } } nodes[MAX_BOOK * 6]; int nodeCnt; TrieNode trieHead;  struct ClassNode {     int bookNum;     int tag;     ClassNode *prev, *next;      ClassNode* Alloc(int _bookNum, int _tag, ClassNode *_prev, ClassNode *_next) {         bookNum = _bookNum;         tag = _tag;         prev = _prev;         next = _next;         if(prev) prev-&gt;next = this;         if(next) next-&gt;prev = this;          return this;     } } classPool[MAX_BOOK * 5]; int classCnt; ClassNode classes[100][500];  int tagHash[TAG_HASH]; int tagCnt; struct Book {     TrieNode* trieNode;     ClassNode* classNodes[5];      Book* Alloc(TrieNode* _trieNode, ClassNode* _classNodes[5]) {         trieNode = _trieNode;         for(int i = 0; i &lt; 5; i++) classNodes[i] = _classNodes[i];          return this;     } } books[MAX_BOOK]; int bookCnt;  int M;  int getTypeIdx(char *type) {     int hash = 0;     while(*type) {         int num;         if(*type &lt;= 'Z' &amp;&amp; *type &gt;= 'A') num = *type - 'A' + 27;         else num = *type - 'a' + 1;         hash = (hash &lt;&lt; 6) + num;         type++;     }     if(tagHash[hash] == -1) tagHash[hash] = tagCnt++;      return tagHash[hash]; }  // #include &lt;stdio.h&gt; // void showBooks() { //     printf(\"@@@\\n\"); //     for(int i = 0; i &lt; M; i++) { //         for(int j = 0; j &lt; tagCnt; j++) { //             ClassNode *pivot = classes[i][j].next; //             while(pivot){ //                 if(pivot-&gt;prev) //                     printf(\"Section: %d, Tag: %d, Num: %d, prev: %d\\n\", i, j, pivot-&gt;bookNum, pivot-&gt;prev-&gt;bookNum); //                 else //                     printf(\"Section: %d, Tag: %d, Num: %d, prev: X\\n\", i, j, pivot-&gt;bookNum); //                 pivot = pivot-&gt;next; //             } //         } //     } // }  void init(int _M) {     M = _M;     nodeCnt = 0;     trieHead.Alloc(-1);     classCnt = 0;     for(int i = 0; i &lt; M; i++) {         for(int j = 0; j &lt; 500; j++) classes[i][j].Alloc(-1, -1, nullptr, nullptr);     }      for(int i = 0; i &lt; TAG_HASH; i++) tagHash[i] = -1;      bookCnt = 0;     tagCnt = 0;      return; }  void add(char mName[MAX_NAME_LEN], int mTypeNum, char mTypes[MAX_N][MAX_TAG_LEN], int mSection) {     mSection--;     int cTag[5] = {-1, -1, -1, -1, -1};     for(int i = 0; i &lt; mTypeNum; i++) {         cTag[i] = getTypeIdx(mTypes[i]);     }      TrieNode* pivot = &amp;trieHead;     while(*mName) {         int num;         if(*mName &gt;='A' &amp;&amp; *mName &lt;= 'Z') num = *mName - 'A' + 26;         else num = *mName - 'a';         if(!pivot-&gt;nexts[num]) pivot-&gt;nexts[num] = nodes[nodeCnt++].Alloc(-1);         pivot = pivot-&gt;nexts[num];         mName++;     }      pivot-&gt;bookNum = bookCnt;     ClassNode *cPivots[5] = {nullptr, nullptr, nullptr, nullptr, nullptr};     for(int i = 0; i &lt; mTypeNum; i++) {         cPivots[i] = classPool[classCnt++].Alloc(bookCnt, cTag[i], &amp;classes[mSection][cTag[i]], classes[mSection][cTag[i]].next);     }     books[bookCnt++].Alloc(pivot, cPivots);      return; }  int moveType(char mType[MAX_TAG_LEN], int mFrom, int mTo) {     mFrom--; mTo--;     int tag = getTypeIdx(mType);      ClassNode *pivot = &amp;classes[mFrom][tag];     int cnt = 0;     while(pivot-&gt;next) {         Book *book = &amp;books[pivot-&gt;next-&gt;bookNum];         for(int i = 0; i &lt; 5; i++) {             if(!book-&gt;classNodes[i]) break;             ClassNode *tmp = book-&gt;classNodes[i];             if(tmp-&gt;next) tmp-&gt;next-&gt;prev = tmp-&gt;prev;             if(tmp-&gt;prev) tmp-&gt;prev-&gt;next = tmp-&gt;next;             tmp-&gt;next = classes[mTo][tmp-&gt;tag].next;             if(tmp-&gt;next) tmp-&gt;next-&gt;prev = tmp;             tmp-&gt;prev = &amp;classes[mTo][tmp-&gt;tag];             classes[mTo][tmp-&gt;tag].next = tmp;         }         cnt++;     }  \treturn cnt; }  void moveName(char mName[MAX_NAME_LEN], int mSection) {     mSection--;     TrieNode *pivot = &amp;trieHead;     while(*mName) {         int num;         if(*mName &gt;='A' &amp;&amp; *mName &lt;= 'Z') num = *mName - 'A' + 26;         else num = *mName - 'a';         mName++;         pivot = pivot-&gt;nexts[num];     }     Book *book = &amp;books[pivot-&gt;bookNum];     for(int i = 0; i &lt; 5; i++) {         if(!book-&gt;classNodes[i]) break;         ClassNode *tmp = book-&gt;classNodes[i];         if(tmp-&gt;next) tmp-&gt;next-&gt;prev = tmp-&gt;prev;         if(tmp-&gt;prev) tmp-&gt;prev-&gt;next = tmp-&gt;next;         tmp-&gt;next = classes[mSection][tmp-&gt;tag].next;         if(tmp-&gt;next) tmp-&gt;next-&gt;prev = tmp;         tmp-&gt;prev = &amp;classes[mSection][tmp-&gt;tag];         classes[mSection][tmp-&gt;tag].next = tmp;     }      return; }  void deleteName(char mName[MAX_NAME_LEN]) {     TrieNode *pivot = &amp;trieHead;     while(*mName) {         int num;         if(*mName &gt;='A' &amp;&amp; *mName &lt;= 'Z') num = *mName - 'A' + 26;         else num = *mName - 'a';         mName++;         pivot = pivot-&gt;nexts[num];     }     Book *book = &amp;books[pivot-&gt;bookNum];     for(int i = 0; i &lt; 5; i++) {         if(!book-&gt;classNodes[i]) break;         ClassNode *tmp = book-&gt;classNodes[i];         if(tmp-&gt;next) tmp-&gt;next-&gt;prev = tmp-&gt;prev;         if(tmp-&gt;prev) tmp-&gt;prev-&gt;next = tmp-&gt;next;     }      return; }  int countBook(int mTypeNum, char mTypes[MAX_N][MAX_TAG_LEN], int mSection) {     mSection--;     bool check[MAX_BOOK] = {false, };     for(int i = 0; i &lt; mTypeNum; i++) {         int tag = getTypeIdx(mTypes[i]);         ClassNode *pivot = classes[mSection][tag].next;         while(pivot) {             check[pivot-&gt;bookNum] = true;             pivot = pivot-&gt;next;         }     }     int cnt = 0;     for(int i = 0; i &lt; MAX_BOOK; i++) if(check[i]) cnt++;  \treturn cnt; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Hash"],
        "url": "/swea/11716/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 11696. 멀티유저 파일시스템 (C++, 라이브러리 X)",
        "excerpt":"  B형 실전 문제   풀이   모든 텍스트는 8자 이하의 알파벳 소문자이므로 hash로 40bit에 1대1 대응시킬 수 있다.   따라서 unsiged long long 의 hash값을 이용하기로 했다.   User와 Group은 각각 20개, 10개로 개수가 적으므로 배열로 저장하였다.   Dir는 Tree로 표현하였다.   주의   함수의 파라미터 안에서 ++ 나 –를 사용하는 것은 지양하자.   컴파일러마다 다르게 해석될 수 있다.     코드 GitHub   #define MAX_CALL 10000 #define MAX_USER 20 #define MAX_GROUP 10 #define MAX_DEPTH 50  typedef unsigned long long int ll;  struct Group {     int idx;     ll name;      Group* Alloc(int _idx, ll _name) {         idx = _idx;         name = _name;         return this;     } } groups[MAX_GROUP]; int groupCnt;  struct User {     int idx;     ll name;     int groupIdx;      User* Alloc(int _idx, ll _name, ll groupName) {         idx = _idx;         name = _name;          for(int i = 0; i &lt; groupCnt; i++) {             if(groups[i].name == groupName) {                 groupIdx = i;                 return this;             }         }         groups[groupCnt].Alloc(groupCnt, groupName);         groupIdx = groupCnt++;         return this;     } } users[MAX_USER]; int userCnt;  struct File {     ll name;     ll ext;     File* sibling;      File* Alloc(ll _name, ll _ext, File* _sibling) {         name = _name;         ext = _ext;         sibling = _sibling;         return this;     } } files[MAX_CALL]; int fileCnt;  struct Dir {     int permission;     ll name;     int maker;     Dir* next;     Dir* sibling;     File* file;      Dir* Alloc(int _permission, ll _name, int userIdx, int groupIdx, Dir* _sibling) {         permission = _permission;         name = _name;         next = nullptr;         sibling = _sibling;         file = nullptr;          if(permission == 0) {             maker = userIdx;         } else if(permission == 1) {             maker = groupIdx;         } else maker = -1;          return this;     } } dirs[MAX_CALL]; int dirCnt;  Dir rootDir;  ll getHash(char* name) {     ll hash = 0;     while(*name) {         hash = (hash &lt;&lt; 5) + *name - 'a' + 1;         name++;     }     return hash; }  ll getNextPathHash(char* path, int* cntRet) {     ll hash = 0;     int cnt = 1;     while(*path &amp;&amp; *path != '/') {         hash = (hash &lt;&lt; 5) + *path - 'a' + 1;         path++;         cnt++;     }     *cntRet = cnt;     return hash; }  ll getNextPattern(char* pattern, int* cntRet) {     ll hash = 0;     int cnt = 1;     while(*pattern &amp;&amp; *pattern != '/' &amp;&amp; *pattern != '.') {         hash = (hash &lt;&lt; 5) + *pattern - 'a' + 1;         pattern++;         cnt++;     }     *cntRet = cnt;     if(*pattern == '.') *cntRet += 9;     return hash; }  // #include &lt;stdio.h&gt; // void showTables() { //     printf(\"groups\\n\"); //     for(int i = 0; i &lt; groupCnt; i++) //         printf(\"idx: %d, name: %d\\n\", groups[i].idx, groups[i].name); //     printf(\"users\\n\"); //     for(int i = 0; i &lt; userCnt; i++) //         printf(\"idx: %d, name %d, group: %d\\n\", users[i].idx, users[i].name, users[i].groupIdx); //     printf(\"dirs\\n\"); //     for(int i = 0; i &lt; dirCnt; i++)  //         printf(\"permission: %d, name: %d, maker: %d\\n\", dirs[i].permission, dirs[i].name, dirs[i].maker); //     printf(\"files\\n\"); //     for(int i = 0; i &lt; fileCnt; i++)  //         printf(\"name: %d, ext: %d\\n\", files[i].name, files[i].ext);  //     return; // }  void init() {     groupCnt = userCnt = fileCnt = dirCnt = 0;      char admin[6] = \"admin\";     ll adminHash = getHash(admin);     users[userCnt].Alloc(userCnt, adminHash, adminHash);     userCnt++;      rootDir.Alloc(2, 0, 0, 0, nullptr);  }  void createUser(char userName[], char groupName[]) {     ll userHash = getHash(userName);     ll groupHash = getHash(groupName);     users[userCnt].Alloc(userCnt, userHash, groupHash);     userCnt++;      return; }  int createDirectory(char userName[], char path[], char directoryName[], int permission) {     ll userHash = getHash(userName);     int user, group;     for(int i = 0; i &lt; userCnt; i++) {         if(users[i].name == userHash) {             user = i;             break;         }     }     group = users[user].groupIdx;      Dir *pivot = &amp;rootDir;     path++;     while(*path) {         int adder;         ll dirHash = getNextPathHash(path, &amp;adder);          Dir *nextPivot = pivot-&gt;next;         while(nextPivot) {             if(nextPivot-&gt;name == dirHash) break;             nextPivot = nextPivot-&gt;sibling;         }         pivot = nextPivot;          if(pivot-&gt;permission == 0) {             if(pivot-&gt;maker != user) return 0;         } else if(pivot-&gt;permission == 1) {             if(pivot-&gt;maker != group) return 0;         }         path += adder;     }      pivot-&gt;next = dirs[dirCnt++].Alloc(permission, getHash(directoryName), user, group, pivot-&gt;next);      return 1; }   int createFile(char userName[], char path[], char fileName[], char fileExt[]) {     ll userHash = getHash(userName);     int user, group;     for(int i = 0; i &lt; userCnt; i++) {         if(users[i].name == userHash) {             user = i;             break;         }     }     group = users[user].groupIdx;      Dir *pivot = &amp;rootDir;     path++;     while(*path) {         int adder;         ll dirHash = getNextPathHash(path, &amp;adder);          Dir *nextPivot = pivot-&gt;next;         while(nextPivot) {             if(nextPivot-&gt;name == dirHash) break;             nextPivot = nextPivot-&gt;sibling;         }         pivot = nextPivot;          if(pivot-&gt;permission == 0) {             if(pivot-&gt;maker != user) return 0;         } else if(pivot-&gt;permission == 1) {             if(pivot-&gt;maker != group) return 0;         }         path += adder;     }      pivot-&gt;file = files[fileCnt++].Alloc(getHash(fileName), getHash(fileExt), pivot-&gt;file);      return 1; }  Dir *Q1[MAX_CALL]; Dir *Q2[MAX_CALL]; int find(char userName[], char pattern[]) {     ll userHash = getHash(userName);     int user, group;     for(int i = 0; i &lt; userCnt; i++) {         if(users[i].name == userHash) {             user = i;             break;         }     }     group = users[user].groupIdx;      Dir **Q = Q1;     Q[0] = &amp;rootDir;     int Qcnt = 1;     pattern++;     while(Qcnt) {         int newQcnt = 0;         Dir **newQ;         if(Q == Q1) newQ = Q2;         else newQ = Q1;          int cnt;         ll hash = getNextPattern(pattern, &amp;cnt);         bool wild = false;         if(*pattern == '*') {             wild = true;             pattern += 2;         }         if(cnt &gt; 9) {             cnt -= 9;             if(!wild) pattern += cnt;              bool wildExt = false;             if(*pattern == '*') wildExt = true;             ll extHash = getHash(pattern);              int ans = 0;             for(int i = 0; i &lt; Qcnt; i++) {                 File* pivot = Q[i]-&gt;file;                 while(pivot) {                     if(wild || pivot-&gt;name == hash) {                         if(wildExt || pivot-&gt;ext == extHash) {                             ans++;                         }                     }                     pivot = pivot-&gt;sibling;                 }             }             return ans;         }         if(!wild) pattern += cnt;          for(int i = 0; i &lt; Qcnt; i++) {             Dir* pivot = Q[i]-&gt;next;             while(pivot) {                 if(pivot-&gt;permission == 0) {                     if(pivot-&gt;maker != user) {                         pivot = pivot-&gt;sibling;                         continue;                     }                 } else if(pivot-&gt;permission == 1) {                     if(pivot-&gt;maker != group) {                         pivot = pivot-&gt;sibling;                         continue;                     }                 }                  if(wild) {                     newQ[newQcnt++] = pivot;                     pivot = pivot-&gt;sibling;                     continue;                 }                 if(pivot-&gt;name == hash) {                     newQ[newQcnt++] = pivot;                     break;                 }                 pivot = pivot-&gt; sibling;             }         }          Q = newQ;         Qcnt = newQcnt;     }      return 0; }   ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Hash"],
        "url": "/swea/11696/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 9462. 여행상품추천 (C++, 라이브러리 X)",
        "excerpt":"  B형 실전 문제   풀이   User는 Array에 저장하고, Product는 pid를 기준으로 hash table에 저장하였다.   추가로 각각의 Area에 따라 Product들을 Heap으로 구성하였다.   실수   이중 for문에서 i 와 j 잘 구분하기.     코드 GitHub   #define MAX_USER 1000 #define MAX_AREA 10 #define MAX_FRIENDS 20 #define MAX_ADD 40001 #define HASH_SIZE 100003  struct User { \tint uid; \tint friends[MAX_FRIENDS]; \tint friendCnt; \tint area[MAX_AREA];  \tvoid Init(int _uid) { \t\tuid = _uid; \t\tfor (int i = 0; i &lt; MAX_FRIENDS; i++) friends[i] = -1; \t\tfriendCnt = 0; \t\tfor (int i = 0; i &lt; MAX_AREA; i++) area[i] = 0; \t\treturn; \t} } users[MAX_USER]; int N;  struct Product { \tint pid, price, area; \tbool reserved; \tProduct *next;  \tProduct* Alloc(int _pid, int _price, int _area, Product *_next) { \t\tpid = _pid; \t\tprice = _price; \t\tarea = _area; \t\treserved = false; \t\tnext = _next; \t\treturn this; \t} } products[MAX_ADD]; int productCnt;  Product hashTable[HASH_SIZE];  Product *areas[MAX_AREA][MAX_ADD]; int areaCnt[MAX_AREA]; int M;  bool productCmp(Product* a, Product* b) { \tif (a-&gt;price &gt; b-&gt;price) return false; \telse if (a-&gt;price &lt; b-&gt;price) return true; \tif (a-&gt;pid &gt; b-&gt;pid) return false; \telse return true; }  void switchProducts(int area, int a, int b) { \tProduct* tmp = areas[area][a]; \tareas[area][a] = areas[area][b]; \tareas[area][b] = tmp; \treturn; }  void addHeap(Product *area[], int num) { \tint pivot = num - 1; \twhile (pivot &gt; 0) { \t\tint parent = (pivot - 1) / 2; \t\tif (productCmp(area[parent], area[pivot])) break; \t\telse { \t\t\tProduct *tmp = area[parent]; \t\t\tarea[parent] = area[pivot]; \t\t\tarea[pivot] = tmp; \t\t\tpivot = parent; \t\t} \t} \treturn; }  void popHeap(int area) { \tint num = areaCnt[area] - 1; \tareaCnt[area]--; \tareas[area][0] = areas[area][num]; \tint pivot = 0; \twhile (pivot * 2 + 1 &lt; num) { \t\tint left = pivot * 2 + 1; \t\tint right = pivot * 2 + 2;  \t\tif (right == num) { \t\t\tif(!productCmp(areas[area][pivot], areas[area][left])) \t\t\t\tswitchProducts(area, pivot, left); \t\t\tbreak; \t\t}  \t\tif (productCmp(areas[area][left], areas[area][right])) right = left; \t\tif (!productCmp(areas[area][right], areas[area][pivot])) break; \t\tswitchProducts(area, right, pivot); \t\tpivot = right; \t}  \treturn; }  //#include &lt;stdio.h&gt; //void showProducts() { //\tprintf(\"products\\n\"); //\tfor (int i = 0; i &lt; M; i++) { //\t\tprintf(\"Area %d: \", i); //\t\tfor (int j = 0; j &lt; areaCnt[i]; j++) { //\t\t\tprintf(\"%d \", areas[i][j]-&gt;pid); //\t\t} //\t\tprintf(\"\\n\"); //\t} //\treturn; //}  void init(int _N, int _M) { \tN = _N; \tM = _M; \tproductCnt = 0; \tfor (int n = 0; n &lt; N; n++) users[n].Init(n); \tfor (int m = 0; m &lt; M; m++) areaCnt[m] = 0;  \tfor (int i = 0; i &lt; HASH_SIZE; i++) hashTable[i].Alloc(-1, -1, -1, nullptr);  \treturn; }  void befriend(int uid1, int uid2) { \tuid1--; uid2--; \tusers[uid1].friends[users[uid1].friendCnt] = uid2; \tusers[uid1].friendCnt++; \tusers[uid2].friends[users[uid2].friendCnt] = uid1; \tusers[uid2].friendCnt++;  \treturn; }  void add(int pid, int area, int price) { \tarea--; \tint hash = pid % HASH_SIZE; \tProduct *product = products[productCnt++].Alloc(pid, price, area, hashTable[hash].next); \thashTable[hash].next = product; \tareas[area][areaCnt[area]] = product; \tareaCnt[area]++; \taddHeap(areas[area], areaCnt[area]);  \treturn; }  void reserve(int uid, int pid) { \tuid--; \tint hash = pid % HASH_SIZE; \tProduct *pivot = &amp;hashTable[hash]; \twhile (true) { \t\tif (pivot-&gt;next-&gt;pid == pid) break; \t\telse pivot = pivot-&gt;next; \t} \tusers[uid].area[pivot-&gt;next-&gt;area]++; \tpivot-&gt;next-&gt;reserved = true; \tpivot-&gt;next = pivot-&gt;next-&gt;next;  \treturn; }  int recommend(int uid) { \tuid--; \tint check[10] = { 0, }; \tfor (int i = 0; i &lt; M; i++) { \t\tcheck[i] += users[uid].area[i]; \t} \tfor (int i = 0; i &lt; users[uid].friendCnt; i++) { \t\tfor (int j = 0; j &lt; M; j++) { \t\t\tcheck[j] += users[users[uid].friends[i]].area[j]; \t\t} \t}  \twhile (true) { \t\tint max = 0; \t\tfor (int i = 0; i &lt; M; i++) { \t\t\tif (max &lt; check[i]) max = check[i]; \t\t} \t\tint maxAreas[10]; \t\tint maxCnt = 0; \t\tfor (int i = 0; i &lt; M; i++) { \t\t\tif (max == check[i]) { \t\t\t\tmaxAreas[maxCnt++] = i; \t\t\t\tcheck[i] = -1; \t\t\t} \t\t} \t\tint recomArea = -1; \t\tfor (int i = 0; i &lt; maxCnt; i++) { \t\t\tint area = maxAreas[i]; \t\t\tProduct *product = areas[area][0]; \t\t\twhile (areaCnt[area] &gt; 0 &amp;&amp; areas[area][0]-&gt;reserved) { \t\t\t\tpopHeap(area); \t\t\t} \t\t\tif (areaCnt[area] == 0) continue; \t\t\telse { \t\t\t\tif (recomArea == -1) recomArea = area; \t\t\t\telse { \t\t\t\t\tif (productCmp(areas[area][0], areas[recomArea][0])) { \t\t\t\t\t\trecomArea = area; \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t} \t\tif (recomArea != -1) { \t\t\tint ret = areas[recomArea][0]-&gt;pid; \t\t\treturn ret; \t\t} \t} }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Heap"],
        "url": "/swea/9462/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[lol-discord] 디스코드 봇 전용 롤 전적 검색 모듈 배포",
        "excerpt":"  LoL Discord   Node.js기반 디스코드 봇을 위한 롤 전적 검색 모듈을 배포하였습니다.   데이터는 LoLog.me에서 가져옵니다.       현재 한국어와 영어를 지원합니다.   NPM     LoL Discord   GitHub     LoL Discord   앵무새봇으로 체험해보기     앵무새봇   명령어는 롤 소환사명입니다.   NPM 배포시 참고한 링크     내 NPM 패키지(모듈) 배포하기  ","categories": ["LoL"],
        "tags": ["League of Legend","LoLog.me","Node.js","Discord"],
        "url": "/lol/lol-discord/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[SWEA] 12532. 인플레이션 (C++, 라이브러리 X)",
        "excerpt":"  B형 실전 문제   풀이   최소값의 최대값을 구하는 전형적인 이분탐색 문제이다.   그러나 Price가 99자리수로 하나의 변수에 담기엔 너무 크다.   문자열 형태로 연산을 할 경우 연산 한번에 100번의 연산이 필요하므로 매우 비효율적이다.   따라서 price를 8개의 long long 배열에 49비트씩 나눠서 저장하였다.     코드 GitHub   #define MAXN 50 #define MAX_ANS 3000 #define PRICE_NUM 8 #define PRICE_SHIFT 50 #define MAX_NAME 20 #define HASH_SHIFT 18 #define HASH_SIZE (1 &lt;&lt; HASH_SHIFT)  typedef long long ll;  void priceCpy(ll dst[], const ll src[]) { \tfor (int i = 0; i &lt; PRICE_NUM; i++) dst[i] = src[i]; }  void mMul(ll dst[], int a) { \tfor (int i = 0; i &lt; PRICE_NUM; i++) dst[i] *= a; \tfor (int i = 0; i &lt; PRICE_NUM - 1; i++) { \t\tdst[i + 1] += dst[i] &gt;&gt; PRICE_SHIFT; \t\tdst[i] &amp;= ((ll)1 &lt;&lt; PRICE_SHIFT) - 1; \t} }  bool mSub(ll dst[], const ll src[]) { \tfor (int i = 0; i &lt; PRICE_NUM - 1; i++) { \t\tdst[i] -= src[i]; \t\tif (dst[i] &lt; 0) { \t\t\tdst[i] += (ll) 1 &lt;&lt; PRICE_SHIFT; \t\t\tdst[i + 1]--; \t\t} \t} \tif (dst[PRICE_NUM - 1] &gt;= src[PRICE_NUM - 1]) return true; \telse return false; }  void makePrice(ll dst[], const char src[]) { \tfor (int i = 0; i &lt; PRICE_NUM; i++) dst[i] = 0; \twhile (*src) { \t\tmMul(dst, 10); \t\tint num = *src - '0'; \t\tsrc++; \t\tdst[0] += num; \t} \tmMul(dst, 1); }  void mstrcpy(char dst[], const char src[]) { \tint c = 0; \twhile ((dst[c] = src[c]) != 0) ++c; }  int mstrcmp(const char str1[], const char str2[]) { \tint c = 0; \twhile (str1[c] != 0 &amp;&amp; str1[c] == str2[c]) ++c; \treturn str1[c] - str2[c]; }  struct Product { \tll price[PRICE_NUM]; \tint duration; \tchar name[MAX_NAME]; \tProduct *next;  \tProduct* Alloc(const char _price[], int _duration, const char _name[], Product *_next) { \t\tmakePrice(price, _price); \t\tduration = _duration; \t\tmstrcpy(name, _name); \t\tnext = _next; \t\treturn this; \t} }products[MAXN];  Product *hashTable[HASH_SIZE];  int getHash(char *a) { \tunsigned long long hash = 5381; \twhile (*a) { \t\thash = (hash &lt;&lt; 5) + hash + *a - 'a' + 1; \t\ta++; \t} \treturn hash &amp; (HASH_SIZE - 1); }  int N;  void init(int _N, char mName[50][20], char mPrice[50][100], int mDuration[50]) { \tfor (int i = 0; i &lt; HASH_SIZE; i++) hashTable[i] = nullptr;  \tN = _N; \tfor (int i = 0; i &lt; N; i++) { \t\tint hash = getHash(mName[i]); \t\thashTable[hash] = products[i].Alloc(mPrice[i], mDuration[i], mName[i], hashTable[hash]); \t} }  void priceChange(char mName[20], char mPrice[100]) { \tint hash = getHash(mName); \tProduct *pivot = hashTable[hash]; \twhile (mstrcmp(pivot-&gt;name, mName) != 0) { \t\tpivot = pivot-&gt;next; \t} \tmakePrice(pivot-&gt;price, mPrice); }  int daySurvivable(char mMoney[100]) { \tll money[PRICE_NUM]; \tmakePrice(money, mMoney); \tint l = 0; \tint r = MAX_ANS; \tint ans = 0; \twhile (l &lt; r) { \t\tint m = (l + r) / 2; \t\tbool pos = true; \t\tll tmon[PRICE_NUM]; \t\tpriceCpy(tmon, money); \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tint mul = (m / products[i].duration); \t\t\tif (m % products[i].duration) mul++; \t\t\tll sub[PRICE_NUM]; \t\t\tpriceCpy(sub, products[i].price); \t\t\tmMul(sub, mul); \t\t\tif (!mSub(tmon, sub)) { \t\t\t\tpos = false; \t\t\t\tbreak; \t\t\t} \t\t} \t\tif (pos) { \t\t\tans = m; \t\t\tl = m + 1; \t\t} \t\telse { \t\t\tr = m; \t\t} \t} \treturn ans; }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","SWEA","C++","Banary Search"],
        "url": "/swea/12532/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[AWS EC2 Windows] 재부팅 후 PM2 자동 실행 (사용자 데이터 스크립트)",
        "excerpt":"  리눅스의 경우 pm2 save와 pm2 startup 명령어를 사용해 재부팅시 pm2가 자동 실행되도록 할 수 있습니다.   그러나 pm2 startup 명령어는 아직 Unix 계열 운영체제에서만 작동합니다.   대신 윈도우 서버에서는 AWS EC2의 사용자 데이터 스크립트 기능을 사용하면 됩니다.    pm2 설치 경로 변경   npm install pm2 -g 명령어로 pm2를 설치했을 경우 pm2는 사용자 디렉토리에 저장됩니다.   사용자 데이터 스크립트로는 사용자 디렉토리에 접근할 수 없으므로 npm -g의 기본 경로를 변경해줍니다.   npm config 명령어로 npm의 기본 디렉토리를 접근하기 쉬운 경로로 변경해줍니다.   &gt; npm config set prefix \"C:\\\\npm\" &gt; npm config set cache \"C:\\\\npm-cache\"   pm2를 다시 설치합니다. (사용자 디렉토리에 있는 모듈들을 제거하고 바꾼 위치에 다시 설치합니다)   npm install pm2 -g   이제 사용자 데이터 스크립트를 사용해 pm2를 실행시킬 수 있습니다.   사용자 데이터 스크립트 편집      사용자 데이터 스크립트를 편집하기 위해서는 인스턴스가 중지된 상태여야합니다.   인스턴스를 중지하고, 인스턴스 설정 -&gt; 사용자 데이터 편집 탭에 들어갑니다.   스크립트를 입력하고 저장합니다.   &lt;powershell&gt; 과 &lt;/powershell&gt; 사이에 시작시 실행할 powershell 명령어를 입력합니다.   저의 경우 앵무새봇의 경로로 이동하고 pm2를 실행하는 스크립트를 작성하였습니다.   사용자 데이터 스크립트는 기본적으로 인스턴스를 처음 시작할때에만 실행됩니다.   마지막에 &lt;persist&gt;true&lt;/persist&gt;를 입력해주면 재부팅을 할때마다 스크립트가 실행됩니다.   &lt;powershell&gt; cd C:\\Users\\Administrator\\parrot-bot-discord pm2 start parrot-bot.js --time &lt;/powershell&gt; &lt;persist&gt;true&lt;/persist&gt;   EC2Launch script 실행      사용자 데이터 스크립트 편집을 하고 인스턴스를 재시작하면 스크립트가 실행되지 않습니다.   EC2Launch script를 실행하여 사용자 데이터 스크립트가 실행되도록 해야합니다.   EC2 인스턴스에 접속하여 EC2 Launch Setting을 실행합니다.   EC2 Launch Setting의 Sysprep 탭에서 Shutdown with Sysprep 버튼을 눌러 인스턴스를 중단합니다. (약간의 시간이 소요됩니다)   인스턴스가 완전히 종료되면 인스턴스를 재시작합니다.   이번에는 사용자 데이터 스크립트가 정상적으로 실행됩니다.   스크립트에 &lt;persist&gt;true&lt;/persist&gt;를 추가했다면 재부팅할 때마다 스크립트가 자동으로 실행됩니다.   Reference           시작 시 Windows 인스턴스에서 명령 실행            npm 모듈의 전역 설치 위치 변경      ","categories": ["AWS"],
        "tags": ["AWS","EC2","PM2"],
        "url": "/aws/window-startup/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[Jekyll, GitHub Page] '이 카테고리의 다른 글' 만들기",
        "excerpt":"  방문자들이 관련 포스트를 쉽게 찾아갈 수 있도록 ‘이 카테고리의 다른 글’ 링크를 만들었습니다.     Lequid 문법  Jekyll 페이지의 문서에 Liquid 코드를 추가하면 빌드되면서 실행됩니다. Liquid를 이용하면 각 페이지에 맞는 링크들을 자동으로 생성할 수 있습니다.      Liquid   Liquid 문법은 공식 문서에서 확인할 수 있습니다.   관련 포스트 선정하기  Liquid를 이용해서 같은 카테고리의 포스트들 중에서 이전 포스트 2개, 현재 포스트, 이후 포스트 2개를 선정합니다. 이전 포스트가 모자랄 경우 이후 포스트로 채우고 이후 포스트가 모자랄 경우 이전 포스트로 채웁니다.   현재 포스트에는 highlight 타입을 주어서 강조되도록 하였습니다.   this-category.html   {% assign maxPosts = 5 %} {% assign maxNext = 2 %}  {% assign catPosts = \"\" | split:',' %} {% assign postCnt = 0 %} {% assign prevCnt = 0 %} {% assign nextCnt = 0 %}  {% for post in site.posts %}     {% if page.categories[0] != post.categories[0] %}         {% continue %}     {% endif %}     {% if post.id == page.id %}         {% assign nextCnt = nextCnt | plus: 1 %}         {% assign postCnt = postCnt | plus: 1 %}         {% assign catPosts = catPosts | push: post }     {% assign catPosts = catPosts | push: post }     {% endif %}     {% elsif nextCnt == 0 %}         {% assign catPosts = catPosts | push: post %}         {% assign postCnt = postCnt | plus: 1 %}         {% assign prevCnt = prevCnt | plus: 1 %}     {% else %}         {% if nextCnt &gt; maxNext %}             {% if maxPosts == postCnt %}                 {% break %}             {% endif %}         {% endif %}         {% assign catPosts = catPosts | push: post %}         {% assign postCnt = postCnt | plus: 1 %}         {% assign nextCnt = nextCnt | plus: 1 %}      {% endif %}     {% if maxPosts &lt; postCnt %}         {% assign catPosts = catPosts | slice: 1, 5 %}         {% assign postCnt = postCnt | minus: 1 %}     {% endif %} {% endfor %}  &lt;div&gt;     &lt;h3&gt;&lt;a href=\"/categories#{{ page.categories[0] | slugify }}\"&gt;{{ page.categories[0] }}&lt;/a&gt; 카테고리의 다른 글&lt;/h3&gt;     &lt;div&gt;         {% for post in catPosts %}             {% if post.id == page.id %}                 {% include archive-shorts.html type=\"highlight\" %}             {% else %}                 {% include archive-shorts.html type=\"list\" %}             {% endif %}         {% endfor %}     &lt;/div&gt; &lt;/div&gt;   각 포스트의 html 형태 설정  기존의 archive-single.html 에서는 포스트의 제목만 나열하는 리스트가 없었습니다. 그래서 포스트의 제목들을 리스트로 나열할 수 있도록 archive-shorts.html을 작성해주었습니다.   archive-shorts.html   {% if post.id %}   {% assign title = post.title | markdownify | remove: \"&lt;p&gt;\" | remove: \"&lt;/p&gt;\" %} {% else %}   {% assign title = post.title %} {% endif %}  &lt;div class=\"{{ include.type | default: 'list' }}__item\"&gt;   &lt;a href=\"{{ post.url | relative_url }}\" rel=\"permalink\"&gt;&lt;li&gt;{{ title }}&lt;/li&gt;&lt;/a&gt; &lt;/div&gt;   CSS로 기존 포스트 강조  this-category.html 에서 현재 포스트에 highlight 타입을 주었으므로 현재 포스트에 해당되는 링크는 highlight__item class에 속하게 됩니다.   _archive.scss 파일에 highlight__item 을 강조하는 코드를 추가합니다.  .highlight__item {   text-decoration: underline;   font-weight: 700; }   원하는 위치에 카테고리 코드 삽입  포스트의 기본 레이아웃이 되는 single.html 레이아웃의 원하는 위치에 위에서 작성한 this-category.html 을 include 해줍니다.   {% include this-category.html %}  {{ content }}  {% include this-category.html %}   저는 포스트를 읽기 전이나 읽은 후에 참고할 수 있도록 컨텐츠의 앞뒤로 하나씩 넣어주었습니다.   결과      원했던대로 같은 카테고리의 이전 포스트 2개, 현재 포스트, 이후 포스트 2개의 링크가 만들어졌습니다. 그리고 현재 포스트는 강조됩니다!   Reference     Liquid  ","categories": ["Blog"],
        "tags": ["Jekyll","GitHub Page","Liquid"],
        "url": "/blog/category/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[Jekyll, GitHub Page] '이 카테고리의 다른 글'에 날짜 추가",
        "excerpt":"  지난번 포스트에서 만들었던 ‘이 카테고리의 다른 글’에 날짜를 추가하고 손가락 이모티콘을 사용하여 가독성을 높혔습니다.    만들었던 ‘이 카테고리의 다른 글’      날짜가 없어 불편하고, 디자인이 게시물 내용과 똑같아서 튀지 않습니다.   날짜 추가  span태그로 날짜를 추가해줍니다. 이번에도 Liquid를 사용하여 post.date를 파싱하였습니다. post.date를 (0, 10)으로 슬라이스하면 yyyy-mm-dd 형태로 날짜가 표기됩니다.   (다만 UTC 기준이라 한국 기준 날짜와 차이가 있을 수도 있습니다.)   &lt;span class=\"date__text\"&gt;{{ post.date | slice: 0, 10}}&lt;/span&gt;&lt;/a&gt;   날짜를 따로 span로 추가한 이유는 제목과 날짜에 각각 다른 글자 크기와 색깔을 사용할 것이기 때문입니다. 이를 위해 li 태그를 div 태그로 바꿔주고 data__item 클래스를 추가해주었습니다.   &lt;div class=\"{{ include.type | default: 'list' }}__item date__item\"&gt;   ~~~ &lt;/div&gt;   이모티콘 추가   li 태글 div 태그로 바꾸었기 때문에 제목 앞에 동그라미가 생기지 않습니다. 대신, 이모티콘을 추가해서 더 눈에 띄도록 해보았습니다.   추가로 현재 보고있는 포스트는 손가락이 반대방향을 가르키도록 하였습니다. 이때도 Liquid를 이용해 post.id 와 page.id를 비교하면 됩니다.   {% if post.id %}   {% assign title = post.title | markdownify | remove: \"&lt;p&gt;\" | remove: \"&lt;/p&gt;\" %} {% else %}   {% assign title = post.title %} {% endif %}  &lt;div class=\"{{ include.type | default: 'list' }}__item date__item\"&gt;   {% if post.id == page.id %}     &lt;a href=\"{{ post.url | relative_url }}\" rel=\"permalink\"&gt;👈 {{ title }} &lt;span class=\"date__text\"&gt;{{ post.date | slice: 0, 10}}&lt;/span&gt;&lt;/a&gt;   {% else %}     &lt;a href=\"{{ post.url | relative_url }}\" rel=\"permalink\"&gt;👉 {{ title }} &lt;span class=\"date__text\"&gt;{{ post.date | slice: 0, 10}}&lt;/span&gt;&lt;/a&gt;   {% endif %} &lt;/div&gt;   위는 수정된 archive-shorts.html 의 전체 코드 입니다.   SCSS 수정  SCSS를 수정해 제목과 날짜에 각각 다른 폰트 크기와 색상이 적용되도록 해줍니다.   _archive.scss  .date__item {   font-size: $type-size-6;   margin-left: 30px;   text-indent: -30px;   .date__text {     font-weight: 500;     color: gray;     font-size: $type-size-8;     white-space:nowrap;   } }   margin-left: 30px; text-indent: -30px; 이 코드는 각각의 리스트를 내어쓰기 해줍니다.   white-space:nowrap; 이 코드는 줄바꿈이 일어나서 날짜가 잘리는 것을 방지해줍니다.   결과      좀 더 그럴듯한 ‘이 카테고리의 다른 글’ 이 만들어졌습니다.   Reference     [HTML/CSS] 들여쓰기 및 내어쓰기 방법   CSS 줄바꿈 금지 - white-space:nowrap;  ","categories": ["Blog"],
        "tags": ["Jekyll","GitHub Page","Liquid"],
        "url": "/blog/category-date/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[npm 오류] Error: not found: make",
        "excerpt":"  앵무새봇의 서버를 증설하기 위해 새로운 AWS EC2 인스턴스를 생성하였습니다.   서버에 nvm과 Node.js를 설치하고 프로젝트를 클론한 뒤에 npm install 명령어를 실행하였으나 Error: not found: make 오류가 뜨면서 모듈 하나가 설치되지 않았습니다.     해결 방법  build-essential을 설치하면 해결됩니다.   $ sudo apt-get install build-essential   Reference     npm failed to install time with make not found error   자습서: Amazon EC2 인스턴스에서 Node.js 설정  ","categories": ["Node.js"],
        "tags": ["Node.js","npm"],
        "url": "/nodejs/make-not-found/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[PM2 옵션] 앱 이름, 시간 로그, argv, 메모리 제한 (`--name`, `--time`, `--` , `--max-memory-restart`)",
        "excerpt":"  앵무새봇을 배포할 때 사용하는 PM2 옵션입니다.     --time  로그가 찍힐 때 시간도 함께 찍히도록 합니다.   --name myApp  앱을 실행할 때에 이름을 붙여줍니다. 같은 스크립트를 여러개 실행해야할 때 유용합니다. (각각 다른 이름 붙이기)   -- myArg1 myArg2  앱을 실행할 때에 매개변수를 줄 수 있습니다. 스크립트에서 접근할 때에는 process.argv[] 로 접근합니다. (process.argv[2] = myAgr1)   --max-memory-restart 100M  앱의 메모리 상한선을 설정합니다. 메모리가 상한선을 초과할 경우 앱이 자동으로 재시작됩니다.   예제  $ pm2 start parrot-bot.js --time --name parrot0 -- 0 2 --max-memory-restart 800M   ecosystem.config.json 에서 사용     [PM2] Configuration File 로 프로세스 한번에 관리하기   Reference     PM2 Process Management Quick Start   process.argv  ","categories": ["Node.js"],
        "tags": ["Node.js","pm2"],
        "url": "/nodejs/pm2-options/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[PM2] Configuration File 로 프로세스 한번에 관리하기",
        "excerpt":"  PM2를 사용할 때에 Configuration File 을 생성해놓으면 여러 프로세스들을 한번에 실행할 수 있고, 옵션도 편리하게 추가할 수 있습니다.     Configuration File 생성  pm2 명령어로 간단하게 Configuration File (ecosystem.config.js) 을 생성할 수 있습니다.  $ pm2 init simple   ecosystem.config.js 작성  생성된 ecosystem.config.js 파일을 원하는 대로 수정해줍니다.   앵무새봇 서버의 경우 아래와 같이 설정해주었습니다.  module.exports = {   apps : [{         name   : \"parrot0\",         script : \"./parrot-bot-discord/parrot-bot.js\",         args: \"2 0\",         time: true,         max_memory_restart: \"600M\"   },   {         name: \"parrot1\",         script: \"./parrot-bot-discord/parrot-bot.js\",         args: \"2 1\",         time: true,         max_memory_restart: \"600M\"   }] }   각 옵션에 대한 설명은 아래를 참고하세요.     [PM2 옵션] 앱 이름, 시간 로그, argv, 메모리 제한 (–name, –time, – , –max-memory-restart)   실행하기  # Start all applications $ pm2 start ecosystem.config.js  # Stop all $ pm2 stop ecosystem.config.js  # Restart all $ pm2 restart ecosystem.config.js  # Reload all $ pm2 reload ecosystem.config.js  # Delete all $ pm2 delete ecosystem.config.js   Reference     Configuration File  ","categories": ["Node.js"],
        "tags": ["Node.js","pm2"],
        "url": "/nodejs/pm2-config/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[LoLog.me] Match-V5 업데이트",
        "excerpt":"  Riot API 의 Match-V4 지원이 종료되었습니다. 그래서 LoLog.me 서버를 Match-V5 에 맞게 업데이트했습니다.     난잡한 코드   업데이트를 하기 위해 코드를 살펴보니 코드 구조가 굉장히 난잡하고 유지보수를 하기 어렵게 짜여져 있는 것을 발견했습니다.   아무래도 Node.js 와 기본적인 웹프로그래밍을 공부하면서 실습용으로 만든 사이트였기 때문에 대강 설계하고 손가는 대로 코드를 짰던 것 같습니다.   이번에 Match-V5 업데이트를 하면서 난잡했던 코드 구조를 깔끔하게 개선하여 리팩토링했습니다. 앞으로는 Riot API 가 바뀌어도 업데이트가 수월할 것입니다.   아직 개선해야할 부분이 정말 많아서 천천히 구조화 시켜나갈 생각입니다.   전적 그래프 삭제   안타깝게도 Match-V4 에서 Match-V5 로 넘어가면서 전적 그래프를 제공할 수 없게 되었습니다.      삭제된 전적 그래프    전적 그래프로 게임을 얼마나 했는지 한눈에 확인하는 전적 그래프 기능은 LoLog.me 의 근본 기능이었습니다.   전적 그래프로부터 모든 기능이 파생됐고, 웹사이트의 이름이 LoLog.me (롤 로그 미) 인 이유 또한 전적 그래프 때문이었습니다.   Match-V4 에서는 유저의 간단한 게임 로그를 최대 100개씩 가져올 수 있었습니다. 그러나 Match-V5 로 업데이트 되면서, 유저당 최대 100개씩 가져올 수 있는 정보는 Match ID 밖에 없었습니다.   이말은 전적 그래프 기능을 계속해서 제공하기 위해서는 Riot API 를 예전보다 100배 더 호출해야 한다는 뜻이고, 이는 Rate Limit 과 반응속도 등의 이유로 불가능한 일입니다.   그래서 아쉽지만 전적 그래프 제공을 중단하기로 했고 LoLog.me 에서 전적 그래프를 제거하였습니다.   바뀐 웹사이트      전적 그래프를 삭제하니 오히려 페이지가 깔끔해졌다는 장점도 있네요.   다만 전적 그래프에 통합돼있던 큐 타입별 전적 검색 기능이 사라져 버렸습니다. 이 기능은 다시 깔끔하게 구현하여 추가해야겠습니다.   +) 웹페이지 테마가 게임 화면 대비 너무 밝아서 게임 화면과 번갈아서 볼 경우 눈이 부실 때가 있습니다. 웹 디자인도 추후에 개선해야겠습니다.   앞으로 해야할 일      코드 구조 개선 작업 지속   큐 타입별 검색 기능 구현   웹 디자인 개선 (어둡게)  ","categories": ["LoL"],
        "tags": ["League of Legend","LoLog.me","Node.js"],
        "url": "/lol/lolog-matchv5/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[Match-V5 업데이트] gameDuration 변경 및 gameEndTimestamp 추가 (Riot API)",
        "excerpt":"  Match-V4 에서 Match-V5 로 넘어가면서 gameDuration(게임 길이) 값이 초단위에서 밀리초단위로 변경되었습니다.   그러나 11.20 패치 이후로 다시 초단위로 돌아가게 되었고 gameEndTimestamp 라는 필드가 새로 생겨났습니다.    Riot API Match-V5 의 공식 안내     Match-V4 에서 Match-V5 로 넘어가면서 gameDuration의 계산 방식이 바뀌었었나봅니다. 이번 11.20 패치 이후부터는 다시 이전의 방식으로 돌아가게 되었습니다.   gameDuration 계산 방식   1. Match-V4, 11.20 이후의 Match-V5   게임에 참여한 플레이어들 중에서 가장 오랜 시간동안 게임을 플레이한 유저의 게임 플레이 시간이 gameDuration 이 됩니다. (초 단위의 값입니다)   2. 11.20 이전의 Match-V5  gameEndTimestamp - gameStartTimestamp:  gameEndTimestamp 는 라이엇 서버에서 게임이 종료되었다고 판단되는 시간입니다. gameStartTimestamp 는 게임이 시작된 시간 입니다. (밀리초 단위의 값입니다)   이전 방식으로 돌아간 이유  1번 방식은 결국 마지막 유저가 게임에서 나간 시간이 gameDuration이 됩니다. 2번 방식의 경우에도 사실상 마지막 유저가 게임에서 나간 시간이 게임이 종료된 시간이니 같은 값의 gameDuration을 갖게 될 것입니다.   그러나 라이엇 서드파티 개발자 커뮤니티에 의하면 특정 서버나 플랫폼의 오류로 인해서 gameEndTimestamp가 실제 게임이 종료된 시간보다 길게 기록되는 경우가 종종 있다고 합니다.   이러한 이유로 1번 방식의 gameDuration은 종종 부정확한 값을 가지게 되었고 다시 원래의 방식으로 돌아가게 된 것입니다.   대응  11.20 패치로 인해 이전 방식으로 돌아갔지만 이전의 게임 로그들은 바뀌지 않았습니다. 따라서 gameDuration 을 불러올 때에 초단위로 쓰였는지 밀리초 단위로 쓰였는지 구분해줄 필요가 있습니다.   라이엇에서 추천하는 방식은 gameEndTimestamp 필드의 유무로 판단하는 것입니다. 11.20 패치 이후로 gameEndTimestamp 라는 필드가 생겼으니 해당 필드가 존재할 경우 gameDuration 은 초단위로 기록되었을 것이고 존재하지 않을 경우 밀리초 단위로 기록되었을 것입니다.   아래는 예제 코드 입니다. (gameDuration 파싱 이후 초단위로 처리합니다)  /** gameDuration &amp; gameEndTimestamp Before or After 11.20 */ if(!data.info.gameEndTimestamp) data.info.gameDuration /= 1000;   Reference     MATCH-V5  ","categories": ["LoL"],
        "tags": ["Riot API","League of Legend"],
        "url": "/lol/game-duration/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[C++ STL] 순열과 조합 (next_permutation)",
        "excerpt":"  코딩테스트를 보는 도중에 순열을 만들어야하는 상황이 있었습니다. 시간은 15분이 남아있었고, next_permutation 함수 사용법이 정확히 기억나지 않았습니다. (어느 라이브러리에 있는지 생각이 나지 않았습니다 ㅠ)   Bitwise 연산으로 조합은 구현해본 적이 있었으나 순열은 직접 구현해본 적이 없었습니다. 남은 10분여의 시간동안 순열을 구하는 알고리즘을 생각해내고 구현을 하기란 쉽지 않았고 결국 다 푼 문제를 순열을 만들지 못해 틀리게 되었습니다.   이번 기회에 next_permutation 함수를 제대로 정리하고 기억해두려합니다. 또한 next_permutaion 함수가 어떻게 생겼는지 살펴보고 순열을 직접 구현할 수 있도록 했습니다.   next_permutation 사용법      std::next_permutation   next_permutation(Arr.begin(), Arr.end());  next_permutation 함수는 위와 같이 사용하고 파라미터로 보내진 Iterator 범위 내의 원소들을 다음 경우의 수 배열로 만들어 줍니다. 이 때, 오름차순에서 내림차순으로 가는 경우의 수를 고려합니다.   즉, 오름차순으로 정렬된 배열에 next_permutation 을 계속 사용하면 모든 경우의 수를 거쳐 결국 내림차순으로 정렬됩니다.   next_permutation 함수는 bool 형식의 값을 반환합니다. 함수가 제대로 작동했으면 true 를 리턴하고 이미 배열이 내림차순으로 정렬되어있을 경우에는 false 를 반환합니다.   예시  다음은 레퍼런스 페이지에서 제공하는 예시입니다.  #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;iostream&gt;   int main() {     std::string s = \"aba\";     std::sort(s.begin(), s.end());     do {         std::cout &lt;&lt; s &lt;&lt; '\\n';     } while(std::next_permutation(s.begin(), s.end())); }  /* OUTPUT */ /* aab    */ /* aba    */ /* baa    */   next_permutation 함수 살펴보기   next_permutation 함수는 이렇게 생겼습니다.  template&lt;class BidirIt&gt; bool next_permutation(BidirIt first, BidirIt last) {     if (first == last) return false;     BidirIt i = last;     if (first == --i) return false;       while (true) {         BidirIt i1, i2;           i1 = i;         if (*--i &lt; *i1) {             i2 = last;             while (!(*i &lt; *--i2))                 ;             std::iter_swap(i, i2);             std::reverse(i1, last);             return true;         }         if (i == first) {             std::reverse(first, last);             return false;         }     } }  위 코드의 알고리즘은 이렇습니다.           맨 뒤에서부터 인접한 두개의 수를 비교한다. (뒤에서부터 내림차순이 아닌 위치를 찾기 위함)            앞의 수(A)가 작을 경우 비교를 멈춘다. (A 뒤에 있는 수들은 내림차순으로 정렬되어있는 상태)            맨 뒤에서부터 A와 비교하여 A보다 커지는 지점(B)을 찾는다.            A와 B를 스왑한다. (여전히 뒤의 수들은 내림차순)            뒤의 수들을 반전시킨다. (내림차순에서 오름차순으로 만든다)       생각보다 간단하고 깔끔한 알고리즘으로 구현되어 있어서 놀랐습니다. 그래서 코딩 테스트 도중에 구현하지 못하였던 것이 더욱 아쉬웠습니다. 이제 순열을 구현하는 방법은 절대 잊지 않을 것 같습니다!   조합으로 사용하기  next_permutation 함수는 조합을 구현할 때에도 사용할 수 있습니다.   0과 1으로만 이루어진 배열(0이 1보다 앞에 있어야함)을 만들어서 next_permutation 함수를 연속적으로 호출하면 000…0111…1 부터 111…1000…1 까지 모든 경우의 수를 얻을 수 있습니다.   예시  #include &lt;algorithm&gt; #include &lt;iostream&gt;   int main() {     int Arr[5] = {0, 0, 1, 1, 1};     std::sort(Arr, Arr+5);     do {         for(int elem : Arr) {             std::cout &lt;&lt; elem;         }         std::cout &lt;&lt; '\\n';     } while(std::next_permutation(Arr, Arr+5)); }  // OUTPUT // 00111 // 01011 // 01101 // 01110 // 10011 // 10101 // 10110 // 11001 // 11010 // 11100   Reference     std::next_permutation  ","categories": ["C++"],
        "tags": ["C++","STL"],
        "url": "/cpp/next_permutation/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "삼성전자 2021 하계 대학생 S/W 알고리즘 역량강화 특강 수료 후기",
        "excerpt":"  2021.07.19 ~ 2021.08.27 6주간 삼성전자 하계 알고리즘 역량강화 특강에 참여하고 수료하였습니다. 이 과정은 삼성전자 SW 역량테스트 B형(Pro) 를 취득하는 것을 목표로 구성된 프로그램입니다. 교육 기간이 종료된 이후에 SW 역량테스트 B형에 응시할 수 있는 기회가 제공됩니다.     신청 &amp; 코딩 테스트  특강 공고는 카카오톡 SW 개발자 취업 공고 오픈채팅방에서 확인했습니다. 특강 대상자가 SW 역량 테스트 A형에 통과할 수 있을 정도의 사람이기 때문에 공개적으로 모집하지는 않은 것 같습니다. 구글, 네이버에 검색해보아도 특강에 대한 정보나 공고에 대한 정보를 확인할 수 없었습니다.   지원서를 접수한 뒤에는 코딩테스트가 진행되었습니다. 총 3문제를 풀어야 했고 시간 제한 없이 기간 내에만 제출하면 됐습니다. 코딩테스트 경험이 있거나 어느정도 구현 능력이 있으면 충분히 통과할 수 있을 정도의 문제였던 것 같습니다. 시간제한이 없고 제출도 여러번 할 수 있었기 때문에 마음편히 볼 수 있었습니다.   테스트 기간이 종료된 바로 다음날 삼성전자 ‘하계 대학생 S/W 알고리즘 역량 강화 특강’ 교육생으로 선정되었다는 메일을 받았고, 바로 3일 뒤에 오리엔테이션이 진행되었습니다.   테스트는 SWEA(SW Expert Academy) 에서 진행되었고 테스트를 미리 대비하기를 원하면 SWEA 에서 모의 역량테스트를 풀어보기를 추천합니다.   오리엔테이션 &amp; 강사 초빙 강연   특강 첫날에는 실시간 온라인 오리엔테이션이 진행되었습니다. 특강 과정에 대한 설명을 들었고, 후반부에는 강사 초빙 강연이 진행되었습니다. 강사님은 알고리즘 교수님(정리해둔 자료를 잃어버려서 성함을 잊어버렸습니다 ㅠ)이었고 알고리즘을 공부해야하는 이유를 재밌게 설명해주셨습니다. 정말 재밌고 유익한 강의여서 알고리즘 공부를 시작하기 전에 의지를 다지는데 큰 도움이 되었습니다.   기초 학습 (4주)   특강은 기본적으로 비대면 자기주도학습으로 진행되었습니다. 4주의 기초학습과 2주의 실전문제 풀이 실습으로 구성되어 있었습니다.   4주간의 기초 학습 기간에는 SW 역량테스트 B형을 통과하기 위해 필요한 여러가지 알고리즘들을 배우게 됩니다. 매일 텍스트로 된 설명 + 온라인 강의 + 관련 문제 가 제공되고 제공된 자료들을 적절히 활용하여 자기주도학습을 해야합니다.   저는 주로 텍스트 설명을 읽으면서 개념를 익히고 문제를 플며 실습했습니다. 온라인 강의는 필요한 부분만 짧게 시청하면서 효율적으로 학습하였습니다.   기초 학습을 진행하면서 STL을 사용하지 않고 여러가지 알고리즘들을 구현하는 방법 및 코딩테스트에서 활용할 수 있는 성능 향상 기법들을 알차게 배울 수 있었습니다. 또한 관련된 문제를 풀면서 추가로 필요하다고 생각하는 내용들을 구글링해보면서 스스로 학습할 수 있었습니다.   실전문제 풀이 (2주)   기초 학습 기간이 종료된 이후로는 2주간의 실전문제 풀이 과정이 진행되었습니다.   첫날에는 실시간 온라인 강의로 B형 테스트가 어떤 형태로 진행되는지 설명해주셨고 여러가지 팁들을 제공해주셨습니다.   이후로는 2주간 매일 실전문제와 해설 영상이 제공되었습니다. 실전문제는 B형 테스트의 난이도와 비슷한 정도의 문제들이기 때문에 실제로 테스트를 치르는 것 처럼 4시간의 시간 제한을 두고 푸는 것이 좋습니다. 문제를 풀고 제출하면 바로 통과 여부를 확인할 수 있지만, 실제 테스트에서는 테스트 케이스를 10개 밖에 제공해주지 않기 때문에 제출은 최소한으로 하고 정확하게 문제를 푸는 연습을 하는 것을 추천합니다. 해설 강의에서는 문제를 풀때 어떤 흐름으로 생각을 하고 문제를 풀어나가야하는지 설명해줍니다.   채용 간담회   특강 막바지에 실시간 온라인 강의로 채용 간담회가 진행되었습니다. 삼성전자 CE/IM 부문에 대한 안내와 채용 관련 설명을 해주셨습니다.   SW 역량테스트 B형 (2회)   특강 과정이 모두 종료된 이후에 2차례(8월 21일, 27일) 의 B형 테스트를 볼 수 있는 기회가 주어졌습니다. 현재 코로나로 인해 상시 SW 역량 테스트가 계속 연기되고 있는 상황이기 때문에 아주 특별한 기회였습니다! 특히 A형을 취득하지 않은 사람도 바로 B형 테스트를 치를 수 있었기 때문에 더더욱 좋은 기회였습니다.   테스트는 비대면으로 진행되었습니다. SW 역량테스트가 온라인으로 진행된 것은 이번이 처음이라고 합니다. (GSAT을 온라인으로 치를 때에도 역량 테스트는 비대면으로 진행되어 왔습니다)   VDI를 통해 삼성전자 서버 내의 데스크톱 환경에 접속하여 테스트를 진행하였습니다. 인터넷 검색은 불가능하고 VDI에 설치된 IDE 만을 사용할 수 있습니다. 스마트폰을 통한 화상 감독과 VDI를 통해 오프라인 테스트와 거의 동일한 환경에서 테스트를 진행했던 것 같습니다.   저는 첫번째 테스트는 아쉽게 통과하지 못했지만 두번째 테스트를 통과하여 Level B (Pro) 를 취득하였습니다. 이는 상시 SW 역량테스트 B형에 통과한 것과 동일한 자격을 취득한 것으로, 삼성전자 공채 지원시 우대를 받고 C형 테스트를 신청할 수 있는 자격을 얻게 됩니다.   테스트 준비에 관한 내용은 다음 글을 참고하세요.     삼성전자 SW 역량테스트 B형 후기 1   수료   삼성전자 2021 하계 S/W 알고리즘 역량강화 특강은 아쉽게도 수료증이 제공되지 않았습니다.   대신 수료 선물로 갤럭시 워치 4!! 를 받았습니다. (역시 삼성!)      수료 기준은 온라인 강의 시청이나 문제 풀이를 80% 이상 완료하는 것이라고 합니다.   후기   이번 특강은 저에게는 정말 알차고 유익했습니다. 자기주도학습이었기 때문에 매일 원하는 만큼 학습할 수 있다는 점과, 양질의 자료를 제공 받아 필요한 만큼 편하게 학습할 수 있다는 점이 너무 만족스러웠습니다.   그리고 모든 강의 과정이 SWEA 플랫폼에서 진행되었는데, (실시간 강의 제외) 강사님에게 쉽고 빠르게 질문이나 피드백을 받을 수 있었고, 수강자들끼리 정보 공유 또한 활발하게 이루어졌습니다.   특강을 수강하면서 학교 강의에서 배웠던 알고리즘들을 다시 한번 체계적으로 정리하는 기회를 가지게 되었습니다. 또한 B형 역량테스트를 통과하기 위한 여러가지 기법들을 배우고 STL을 사용하지 않고 알고리즘을 구현하는 능력을 키울 수 있었습니다.   SW 역량테스트를 치를 수 있는 기회를 얻어 B형을 취득하고 특강을 수료하여 갤럭시 워치까지 선물로 받아서 얻은 것도 많고 배운 것도 많은 알차고 만족스러운 특강이었습니다.  ","categories": ["Study"],
        "tags": ["Review","Algorithm","Samsung"],
        "url": "/study/algorithm2021/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "삼성전자 SW 역량테스트 B형 후기 1 (준비)",
        "excerpt":"  삼성전자 S/W 알고리즘 특강을 수강하여 운좋게 삼성전자 SW 알고리즘 역량테스트 B형(pro) 을 치를 기회를 얻었습니다. 2회의 기회가 주어졌고 저는 두번째 테스트에서 통과하여 B형을 취득하였습니다.    이 글은 제가 B형 테스트를 준비하고 2번의 테스트를 치르면서 느낀점들을 바탕으로 작성한 글입니다. 참고 정도로 보시기를 추천드립니다.   글을 쓰다보니 생각보다 길어져서 이번 포스트에서는 시험 준비 과정에 대한 내용을 다루고 시험을 친 후기는 다음 포스트로 작성하겠습니다.   A형 테스트와 비교   제약사항  지원 언어는 C/C++/Java/Python 으로 같고 라이브러리 또한 사용 가능으로 같습니다. (이전에는 B형의 경우 Python 사용이 불가능하고 라이브러리 사용이 제한되었으나 이번 시험부터 변경되었다고 합니다)   문제 수 &amp; 시간     A형: 3시간 2문제   B형: 4시간 1문제   A형 시험은 문제를 잘 이해하고 주어진 시간 내에 구현할 수 있는가를 확인하는 테스트라고 느꼈습니다. 문제를 잘 읽고 그대로 구현하기만 하면 됩니다.   웬만해선 시간초과나 메모리 초과가 발생할 일이 없을겁니다. (DFS, BFS, DP 등 몇몇 알고리즘만 능숙하게 구현할 수 있으면 통과할 수 있다고 봅니다)   반면 B형은 주어진 문제를 얼마나 효율적으로 해결할 수 있는가를 봅니다. 문제 자체는 A형보다 간단해서 문제 이해하기는 쉽습니다.   그러나 제약사항으로 주어지는 사이즈, 횟수 등이 엄청나게 커서 A형처럼 생각나는 대로 구현하기만 하면 시간초과나 메모리 초과로 절대 통과할 수 없습니다.   여러가지 자료구조나 알고리즘에 대한 이해, 그리고 원하는 대로 변형시키고 능숙하게 구현할 수 있는 능력이 필요합니다.   STL 사용  이제 B형 테스트에서도 A형 테스트와 마찬가지로 STL을 사용해도 된다고 합니다. 그러나 저는 STL을 사용하지 않았습니다.   단순히 STL을 사용하기만 해서 풀 수 있는 문제가 출제되지는 않습니다. 자료구조나 알고리즘을 문제에 맞게 변형하거나 결합시켜야하는 문제들이 출제되므로 저는 오히려 STL을 사용하지 않고 직접 구현하고 변형시키면서 푸는 것이 효율적이라고 느꼈습니다.   STL을 원하는 대로 능숙하게 사용할 수 있고, 어떻게 동작하는지 잘 이해하고 있는 경우가 아닌 이상 STL 없이 푸는 것을 추천합니다.   그리고 SW Expert Academy 에 올라온 연습문제 대부분은 STL을 사용할 수 없을 겁니다. (확실하진 않습니다. 아마 그럴 겁니다!)   1문제를 4시간 동안 푸는 시험이니, STL을 사용하지 않아도 결코 시간이 부족하지 않습니다.   준비  저는 삼성전자 알고리즘 역량강화 과정에 참여하여 공부하였습니다. 자세한 내용은 이전에 포스팅했던 글을 참고하세요.     삼성전자 2021 하계 대학생 S/W 알고리즘 역량강화 특강 수료 후기   알고리즘 공부  B형 테스트를 통과하기 위해선 여러 알고리즘에 대한 이해가 필요합니다.   그러나 알고리즘이라고 해봤자 생각보다 복잡하지 않습니다. 대부분 알고리즘 강의에서 배웠던 내용들이고 개념을 이해하고 구현 연습을 하면 어렵지 않습니다. (제가 까다롭다고 느낀 알고리즘은 KMP, LCA 정도입니다)   공부해볼만한 키워드  Array, Linked List, Bitwise 연산, Greedy, 완전탐색(Brute-Force), BFS, DFS, DP, 분할정복, Sort, Binary Search, Graph, Dijkstra, Tree, LCA, Heap, Trie, KMP, Hash   알고리즘 공부를 하면서 자료구조와 알고리즘의 특징이나 시간복잡도에 대한 생각을 많이 하고 잘 이해해야합니다. 위의 키워드들을 다 이해하고 구현할 수 있을 정도면 충분합니다.   문제 풀이 연습   알고리즘 공부가 잘 됐다면 관건은 문제를 보고 알맞은 알고리즘 &amp; 자료구조를 떠올리고 변형 및 적용하는 것입니다. 여러 문제들을 풀어보고 다른 사람의 풀이를 보면서 생각의 흐름을 익히는 것이 중요합니다.   문제를 보고 아이디어가 바로바로 떠오르면 좋겠지만 쉽지 않습니다. 문제를 풀어보면서 특정 자료구조 &amp; 알고리즘을 사용한 이유를 생각해보고 문제의 제약사항 등을 보면서 차근차근 아이디어를 떠올리는 연습을 해야합니다.   문제는 아래의 흐름대로 풉니다. 무작정 푸는 것보다 효율적이며 시간관리에도 용이합니다.   문제 이해 -&gt; 아이디어 도출 -&gt; 설계 -&gt; 구현 -&gt; 디버깅 -&gt; 최적화   설계  설계과정까지 30분, 넉넉잡아 1시간까지도 줍니다. 설계를 탄탄히 할수록 이후 과정이 수월해지므로 설계에서 시간을 오래 소모했다고 조급해할 필요 없습니다.   여러가지 시나리오를 생각해보며 효율적인 알고리즘을 선택해야합니다. 특히 엣지 케이스를 고려하여 특정 상황에서 큰 시간이 소모될 경우가 없는지 생각해보아야합니다. (edge case와 bad case는 다릅니다. 저격성 케이스는 주어지지 않는다고 봅니다.)   구현  설계를 제대로 했다면 구현은 어렵지 않을 겁니다. 설계한대로 코드만 작성하면됩니다. 그러나 설계할때 생각지 못했던 문제가 발생할 때가 많습니다. 이때는 구현을 잠시 멈추고 다시 설계를 신중히 수정하는 것이 좋습니다.   구현하면서 그때그때 되는 대로 설계를 수정하게 되면 또 새로운 문제가 발생할 확률이 높고 설계할 때 고려했던 사항들이 무시되는 상황이 발생할 수 있습니다. 조급해하지 말고 신중히 다시 설계하는게 오히려 효율적입니다.   디버깅  구현을 끝냈으면 테스트 케이스를 실행해보면서 디버깅을 합니다. 이때 main 함수나 테스트 셋을 수정해보면서 버그를 찾고 엣지 케이스에서 잘 동작하는지 확인합니다.   B형 테스트는 main 함수는 수정할 수 없고 solution 함수만 구현하면 됩니다. 그러나 디버깅을 하면서 main 함수를 수정하여 로그를 찍는 등의 과정이 필요하므로 문제를 풀면서 main함수를 수정해보는 연습도 해보면 도움이 됩니다.   최적화  디버깅까지 마쳤을 때 시간이 남는다면 최적화를 해줍니다. 중복된 연산, 불필요한 연산 등을 찾아 최적화해줍니다. 시간이 얼마남지 않았다면 시간초과가 나지 않는 이상 무리하게 최적화 작업을 하는 것은 추천하지 않습니다. 마지막에 급하게 제출하면 예상치못한 버그가 발생할 수 있기 때문입니다.  ","categories": ["Study"],
        "tags": ["Review","Algorithm","Samsung"],
        "url": "/study/samsungb/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "[Match-V5] 게임 타입(큐 타입) 알아내기 (Riot API)",
        "excerpt":"  Match-V5 에서 큐 타입 (솔랭, 자랭, 일반 등) 은 info 오브젝트의 queueId 필드에 나와있습니다.    queueId  queueId 필드는 int를 반환하는데, 이는 각각 큐 타입의 고유 넘버입니다. 큐 타입에 대한 자세한 정보는 공식 문서에서 확인할 수 있습니다.     queues.json   예시  LoLog.me 에서는 queueId를 다음과 같이 파싱합니다.  const QUEUETYPE = {     400: 'norm', //Normal Draft Pick     420: 'solo',     430: 'norm',     440: 'flex',     450: 'aram',     700: 'clash',     800: 'ai',  // Deprecated     810: 'ai',  // Deprecated     820: 'ai',  // Deprecated     830: 'ai',     840: 'ai',     850: 'ai',     900: 'urf',     920: 'poro',     1020: 'ofa',     1300: 'nbg',     1400: 'usb', // Ultimate Spellbook     2000: 'tut',     2010: 'tut',     2020: 'tut', }   한국어로 번역했을 때,  const ko = {   \"solo\": \"솔랭\", \t\"norm\": \"일반\", \t\"aram\": \"칼바람\", \t\"flex\": \"자랭\", \t\"nbg\": \"돌넥\", \t\"usb\": \"궁주문서\", \t\"urf\": \"URF\", \t\"ofa\": \"단일\", \t\"ai\": \"AI대전\", \t\"poro\": \"포로왕\", \t\"tut\": \"튜토리얼\", \t\"etc\": \"기타\", \t\"clash\": \"격전\" }   Reference     LoL Documents   LoLog.me  ","categories": ["LoL"],
        "tags": ["Riot API","League of Legend"],
        "url": "/lol/queue-id/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "삼성전자 SW 역량테스트 B형 후기 2 (첫번째 테스트)",
        "excerpt":"  이전 글에 이어지는 삼성전자 SW 알고리즘 역량테스트 B형 취득 후기입니다. 이번 글에서는 2번의 시험 중 첫번째 시험을 치르면서 느낀 점을 정리해보았습니다.    삼성전자 SW 알고리즘 역량강화 특강에 참가하여 2번의 B형 테스트를 치를 수 있는 기회를 얻었습니다. 현재 코로나로 인해 상시 테스트가 계속 미뤄지고있는 것으로 알고 있는데, 정말 좋은 기회를 얻었습니다.   B형 테스트  이번 테스트는 최초로 비대면으로 진행되었다고 합니다. VDI (가상 데스크탑) 을 이용하여 대면 시험과 거의 동일한 환경에서 테스트가 진행되었습니다.   인터넷 접속은 불가능하고 VDI에 설치된 IDE (Visual Studio, Pycharm, Eclipse) 만을 이용할 수 있습니다. 대면시험과 동일한 환경에 화상 감독으로만 변경되었다고 생각하시면 됩니다.   앞으로 테스트가 어떤 형태로 진행될 지는 모르겠지만 비대면 시험도 괜찮다고 느꼈습니다. 본인이 익숙한 장소에서 익숙한 장비(모니터, 키보드) 로 시험을 치를 수 있고, 직접 왔다갔다하는 번거로움이 없어서 좋았습니다!   8월 21일 첫시험  첫 시험은 사실 별로 긴장을 하지 않고 봤습니다. 실전문제 몇문제를 풀어본 상태였고 한번의 기회가 더 있었기에 가벼운 마음으로 임했습니다. 심지어 필기할 펜과 종이도 준비하지 않았습니다. (메모장 앱을 사용하였습니다.)   다소 자만하여 시험에 임했고, 결과적으로는 제대로 당했습니다…   시험 문제를 봤을 때 첫 느낌은 “너무 쉬운데…?’ 였습니다. 그러나 제약사항을 보고 B형 시험이 테스트하고 싶어하는 것이 무엇인지 깨달았습니다. A형에서는 볼 수 없는 엄청난 사이즈의 제약사항 (1억, 10억…) 을 보았고 어떻게 풀어야할 지 생각해 보았습니다.   문제 자체는 언젠가 한번쯤 접했을 법한 심플한 문제였습니다. 그러나 사이즈 제약이 커서 효율적으로 동작시키는 것이 관건인 문제였습니다.   배열을 사용하는 것은 당연히 불가능하고, 저는 세개의 링크드 리스트를 만들어 서로 연관시키는 방식으로 알고리즘을 설계했습니다. 배드 케이스에서는 시간초과가 날 수 있으나 더 효율적인 방식은 존재하지 않는다고 판단하였습니다.   설계한 대로 구현하던 도중, 링크드리스트를 3개 대신 2개만 이용하여 풀면 코드가 더 간결해질 것이라고 생각했습니다. 2개로 푸나 3개로 푸나 배드케이스는 같아서 시간복잡도에서 손해를 보지 않을 것이라고 생각했습니다. (이게 큰 실수였습니다.)   그래서 구현 도중 설계를 바꾸었고 그대로 구현을 끝마쳤습니다. 테스트 결과 애매한 시간이 나왔고, 테스트 케이스를 하나씩 체크해보며 어디에서 시간이 많이 소모되는지 확이하였습니다.   25개의 테스트 케이스 중에서 단 하나의 케이스만 과도하게 시간이 오래 걸리는 것을 확인했습니다. 해당 테스트 케이스를 분석해보았고, 처음 설계했던 대로 3개의 링크드 리스트로 구현했어야 했음을 깨달았습니다.   그러나 코드의 큰 틀을 바꾸기엔 이미 시간이 너무 지나버렸고, 결국 그대로 제출할 수밖에 없었습니다.   운이 정말 좋지 않는 이상 통과할 수 없을 것이라고 생각했고, 역시나 이번 테스트에서는 통과하지 못했습니다.   느낀점  첫 시험을 치르면서 느낀점이 많았습니다.   자만하지 말자  처음 보는 시험을 너무 쉽게 생각했던 것 같습니다. 다음 시험은 제대로 준비하고 진지하게 임해야겠다고 생각했습니다.   배드 케이스 &amp; 엣지 케이스  제가 처음에 설계했던 알고리즘과 중간에 바꾼 알고리즘의 배드 케이스 시간복잡도는 같았습니다. 그러나 실제로 배드 케이스는 아주 특수한 저격성 시나리오에서만 발생하게 됩니다. 일반적으로 그런 시나리오는 주어지지 않는다고 봅니다.   일반적인 시나리오에서는 바꾼 구조가 살짝 비효율적이나 시간복잡도는 같았습니다. 둘 다 충분히 통과할 수 있을 만한 시간복잡도를 가집니다.   그러나 문제는 엣지 케이스에서 발생했습니다. 처음 설계했던 구조에서는 엣지 케이스에서도 일반적인 케이스와 비슷한 시간 복잡도를 가졌습니다. 그러나 두번째 구조에서는 엣지 케이스의 경우에 배드 케이스와 동일한 시간복잡도를 가졌습니다.   가능한 시나리오를 생각해보고 여러가지 형태의 테스트 케이스에 대해서 생각해 보아야합니다. 이때, 일부러 저격하지 않는 이상 발생하지 않는 시나리오는 배제하여도 무방합니다.   구현 도중 설계를 바꿀 경우  만약 제가 중간에 설계를 바꾸지 않았다면 테스트를 통과할 수 있었을 것입니다. 그러나 구현 도중 설계를 바꿔야하는 상황은 빈번하게 발생합니다.   설계한 대로 100% 구현할 수 있는 상황은 거의 없습니다. 따라서 구현 도중 설계를 바꿔야할 상황이 오면 다시 설계 단계로 돌아가 신중히 생각해보는 과정을 거쳐야합니다.   제가 설계를 바꿔야겠다고 생각하고 잠시 구현을 멈추고 다시 설계하면서 여러 케이스에 대해 신중히 고민했다면 이번과 같은 실수는 발생하지 않았을 것입니다.   급하게 코드를 작성하지 않고 신중히 생각하면서 문제를 풀어나가는 자세가 필요합니다.   8월 27일 두번째 시험  첫번째 시험에서 많은 것을 느끼고 두번째 시험은 제대로 준비하고 제대로 치렀습니다.   이에 대한 내용은 다음 글로 남기겠습니다.  ","categories": ["Study"],
        "tags": ["Review","Algorithm","Samsung"],
        "url": "/study/samsungb2/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "삼성전자 SW 역량테스트 B형 후기 3 (두번째 테스트)",
        "excerpt":"  이전 글에 이어지는 삼성전자 SW 알고리즘 역량테스트 B형 취득 후기입니다. 이번 글에서는 2번의 시험 중 두번째 시험을 치르면서 느낀 점을 정리해보았습니다.    준비  첫번째 시험에서 떨어졌다고 생각을 하고 두번째 시험은 더 열심히 준비했습니다.   배웠던 알고리즘들을 다시 한번 살펴보고 제가 구현했던 코드도 다시 읽어보았습니다.   실전 문제도 시간을 체크하면서 4문제 더 풀었습니다.   8월 27일 두번째 시험  시험 당일 오전에 첫번째 시험의 결과가 메일로 안내되었습니다. 저는 예상한대로 통과하지 못했습니다. 첫시험 결과를 알고 두번째 시험을 봤기 때문에 더 열심히 볼 수 있었던 것 같습니다.   이번에는 시험에 진지하게 임했고, 메모할 종이도 챙겼습니다.   문제를 처음 봤을 때는 조금 당황했습니다. 생각치도 못했던 생소한 유형의 문제가 나왔기 때문입니다.   첫시험에서 제대로 풀어야했다고 후회하다가 마음을 다잡았습니다. 나름 철저히 준비했기 때문에, 제가 풀지 못할 문제는 나오지 않을 것이라고 생각했습니다. 내가 못풀면 아무도 못풀 것이라는 마음으로 자신감을 갖고 문제를 풀기 시작했습니다.   아이디어 도출 및 설계  처음 아이디어를 떠올리는 과정이 제일 어려웠습니다. 어떤 자료구조와 알고리즘을 사용할 수 있는지 하나씩 따져보았습니다. 결국 트리 + DP로 충분히 구현할 수 있겠다는 생각이 떠올랐습니다.   떠올린 아이디어를 실제로 구현할 수 있도록 구체화하여 코드를 설계했습니다. 구체적인 알고리즘과 노드 구조 등을 철저히 설계하였습니다.   구현  구현은 설계한 대로 수월하게 수행하였습니다. 구현 도중에 구조를 조금씩 신중하게 변경하였습니다. 첫번째 시험 때의 실수를 반복하지 않도록, 구조를 변경할 때에는 또다른 문제가 발생하지 않는지 꼭 체크하였습니다.   디버깅  구현을 모두 마친 뒤에는 테스트해보면서 디버깅을 진행했습니다. 오타 등 자잘한 버그 외에 큰 문제는 없었습니다.   최적화  테스트 결과 실행 시간이 꽤 괜찮게 나왔습니다. 그래도 남은 시간동안 최적화를 진행하였습니다.   메인 함수를 수정하여 로그를 찍어보면서 불필요한 연산을 제거하였습니다. 또한 트리에서 중복된 노드를 제거하였습니다.   시험이 종료될 때까지 최적화를 진행하였고, 그 결과 4-5배 정도 빠른 실행시간을 얻을 수 있었습니다. 특수한 버그나 오류가 없으면 무난히 통과할 수 있을 만한 결과를 얻었습니다.   시험 결과  8월 27일에 치른 두번째 테스트에 통과하여 삼성전자 SW 알고리즘 역량 테스트 Level B(Pro) 를 취득하였습니다.  ","categories": ["Study"],
        "tags": ["Review","Algorithm","Samsung"],
        "url": "/study/samsungb3/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "오징어 게임 징검다리 건너기 참가자별 성공 확률 1 (계산)",
        "excerpt":"  넷플릭스 드라마 “오징어 게임” 의 5번째 게임은 “징검다리 건너기” 입니다. 18쌍의 강화유리와 일반유리로 이루어진 징검다리를 참가자 16명이 차례로 건너는 게임입니다.   변수가 없는 상황(유리 장인 X, 기억 못하는 경우 X)에서 각 참가자별로 성공할 확률이 얼마나 되는지 계산해보겠습니다.    참가자 수와 확률  참가자 수에 상관 없이 N번째 참가자의 성공 확률은 동일합니다. 참가자 번호가 증가할 수록 성공 확률이 증가하다가 19번째 참가자 부터는 무조건 성공하게 됩니다. 오징어 게임에서는 참가자가 16명 이었지만 19번 참가자까지의 성공 확률을 계산해보겠습니다.   전체 경우의 수  전체 경우의 수를 계산해봅시다. 각각의 유리는 깨지거나, 깨지지 않거나 두가지 경우의 수를 갖고 있습니다. 총 18쌍의 유리가 존재하므로 전체 경우의 수는 2^18 = 262,144 가 됩니다.   각 참가자별 경우의 수  첫번째 참가자가 성공할 경우의 수는 18개의 유리가 모두 깨지지 않을 경우입니다. 이는 18C0, 즉 1입니다.   두번재 참가자가 성공할 경우의 수는 첫번째 참가자가 성공할 확률 + 유리가 1개만 깨질 경우 즉, 18C0 + 18C1 = 19 입니다.   마찬가지로 세번째 참가자가 성공할 확률은 18C0 + 18C1 + 18C2 = 172 가 됩니다.   …   19번째 참가자가 성공할 경우의 수는 18C0 + 18C1 + … + 18C18 = 262,144 입니다. (전체 경우의 수와 같습니다!)   확률  위에서 구한 경우의 수를 바탕으로 각 참가자별 성공 확률을 계산해 보았습니다.                  참가자 번호       경우의 수(18Cn)       누적(Σ18Cn)       성공확률                       1       1       1       0.000381%                 2       18       19       0.00725%                 3       153       172       0.0656%                 4       816       988       0.377%                 5       3060       4048       1.544%                 6       8568       12616       4.813%                 7       18564       31180       11.894%                 8       31824       63004       24.034%                 9       43758       106762       40.726%                 10       48620       155382       59.274%                 11       43758       199140       75.966%                 12       31824       230964       88.106%                 13       18564       249528       95.187%                 14       8568       258096       98.456%                 15       3060       261156       99.623%                 16       816       261972       99.934%                 17       153       262125       99.993%                 18       18       262143       99.9996%                 19       1       262144       100%           이항분포  각 참가자가 본인부터 성공할 확률은 유리가 (본인의 순서 - 1)개 깨질 확률과 같습니다. 이는 성공확률이 1/2 이고, 시행 횟수가 18(유리의 개수)인 이항분포를 따릅니다.      참고자료: Chapter 3 정규분포(Normal distribution)   따라서 각 참가자가 성공할 확률은 확률이 1/2 이고, 시행 횟수가 18인 이항분포의 누적합입니다.   Reference     Chapter 3 정규분포(Normal distribution)   엑셀 COMBIN 함수로 조합수 구하기  ","categories": ["Life"],
        "tags": ["Squid Game"],
        "url": "/life/bridge/",
        "teaser": "/assets/images/teaser.png"
      },{
        "title": "오징어 게임 징검다리 건너기 참가자별 성공 확률 2 (파이썬 테스트)",
        "excerpt":"  이전 글에서 수학적으로 계산했던 오징어 게임 징검다리 건너기 참가자별 성공 확률을 코드로 구현하여 테스트해보았습니다.    게임 함수  게임을 1회 진행하는 함수입니다. level 파라미터는 징검다리의 개수, printBridge는 게임이 끝난 후 징검다리의 모양을 프린트할지 여부입니다. 최초로 성공한 플레이어의 번호를 리턴합니다.   import random  def game(level, printBridge):     res = []     player = 1     for i in range(level):         isBroke = random.randrange(2)         if isBroke:             res.append(True)             player += 1         else:             res.append(False)          if printBridge:         for isBroke in res:             if isBroke:                 print(\"X\", end=\" \")             else:                 print(\"O\", end=\" \")          return player   게임 1회 진행     게임을 1회 진행해본 결과 9번 참가자가 최초로 성공했습니다. 16명의 참가자가 있었다면 8명의 참가자가 성공했겠네요. 드라마 오징어게임보다 많이 생존했습니다!   게임 100만번 진행  res = [] for i in range(19):     res.append(0) for i in range(1000000):     player = game(18, False)     res[player - 1] += 1  print(res)  게임을 100만번 진행하여 최초로 성공한 참가자를 축적하는 코드입니다.   플랏  import matplotlib.pyplot as plt  prob = [] for i in range(19):     prob.append(res[i] / 1000000) plt.plot(range(1, 20), prob, \"o\")  위의 결과를 확률로 계산하여 플랏했습니다.      예상대로 이항분포 꼴의 그래프를 얻었습니다!   각 참가자별 성공 확률  위의 확률을 축적하여 각 참가자별 성공 확률을 계산하고 플랏하였습니다.   resAccum = [] resAccum.append(res[0]) for i in range(18):     resAccum.append(resAccum[i] + res[i+1])  accumProb = [] for i in range(19):     accumProb.append(resAccum[i] / 1000000) plt.plot(range(1, 20), accumProb, \"o\")  for i in range(19):     print(str(i+1) + \"번 참가자: \" + str(round(accumProb[i] * 100, 4)) + \"%\")      1번 참가자: 0.0003% 2번 참가자: 0.0086% 3번 참가자: 0.0688% 4번 참가자: 0.3781% 5번 참가자: 1.5433% 6번 참가자: 4.8335% 7번 참가자: 11.9258% 8번 참가자: 24.0721% 9번 참가자: 40.7867% 10번 참가자: 59.3759% 11번 참가자: 76.0369% 12번 참가자: 88.1458% 13번 참가자: 95.1891% 14번 참가자: 98.4459% 15번 참가자: 99.6244% 16번 참가자: 99.9353% 17번 참가자: 99.9923% 18번 참가자: 99.9996% 19번 참가자: 100.0%  이전 글에서 계산했던 값과 거의 일치하는 결과를 얻었습니다.   전체 코드     bridge.ipynb   Reference     01. Matplotlib 기본 사용  ","categories": ["Life"],
        "tags": ["Squid Game","Python"],
        "url": "/life/bridge2/",
        "teaser": "/assets/images/teaser.png"
      }]
